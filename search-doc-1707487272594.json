{"searchDocs":[{"title":"Container l√∂schen","type":0,"sectionRef":"#","url":"/workshop-container/docs/container_loeschen","content":"Container l√∂schen Es gibt zwei M√∂glichkeiten einen Container zu l√∂schen. Wir starten mit dem einfachsten Weg, um einen Container zu l√∂schen. Zuerst musst du den Namen oder die ID des Containers herausfinden, den du l√∂schen m√∂chtest. docker ps Die Ausgabe sollte √§hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 9 minutes ago Up 9 minutes 3306/tcp focused_noether In diesem Beispiel ist der Name des Containers focused_noether. Um den Container zu l√∂schen, gib ein: docker stop focused_noether Jetzt kannst du √ºberpr√ºfen, ob der Container gestoppt ist, indem du den folgenden Befehl eingibst: docker ps -a Die Ausgabe sollte √§hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 9 minutes ago Exited (0) 2 minutes ago focused_noether Wir haben somit den container &quot;gracefully&quot; gestoppt, aber es gibt auch die M√∂glichkeit, einen Container &quot;forcefully&quot; zu stoppen. Dazu gibst du den folgenden Befehl ein: docker kill focused_noether Wenn der Container gestoppt ist, kannst du ihn l√∂schen, indem du den folgenden Befehl eingibst: docker rm focused_noether Hinweis Es ist eine gute Praxis, Container zu l√∂schen, die nicht mehr ben√∂tigt werden, um Speicherplatz freizugeben. ü§î Wo kommen diese komischen Namen der Container her? Docker generiert automatisch Namen f√ºr Container, wenn du keinen Namen angibst. Das ist n√ºtzlich, wenn du viele Container auf deinem Computer ausf√ºhrst und nicht jedes Mal einen Namen ausdenken m√∂chtest. Wie du einen Container mit einem Namen erstellst, erf√§hrst du im n√§chsten Lab.","keywords":"","version":"Next"},{"title":"Benennen von Containern","type":0,"sectionRef":"#","url":"/workshop-container/docs/container_name","content":"Benennen von Containern Im Gegensatz zur CONTAINER ID ist der NAME etwas, das wir manipulieren k√∂nnen. Der Name ist praktisch, nicht nur zum Starten/Verbinden/Stoppen/Zerst√∂ren eines Containers, sondern auch f√ºr das Networking (was wir in einem sp√§teren Lab sehen werden). Um einen Namen zu setzen, f√ºge den Parameter --name zum run Befehl von Docker hinzu: docker run --name mariadb-container -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb Wie immer, um zu √ºberpr√ºfen, ob dies wirklich funktioniert hat, schau dir die Container-Liste an: docker ps Die Ausgabe sollte √§hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 9 minutes ago Up 9 minutes 3306/tcp mariadb-container Anstatt wie im letzten Lab auf die Datenbank von innerhalb des Containers zuzugreifen, greifen wir von aussen mit einem lokalen mysqlclient darauf zu. Das ist ein bisschen knifflig. Zuerst musst du die IP-Adresse deines Docker-Containers herausfinden. Daf√ºr verwendest du diesen Befehl: docker inspect mariadb-container -f '{{ range.NetworkSettings.Networks }}{{ .IPAddress }}{{ end }}' docker inspect &lt;container&gt; zeigt dir Details √ºber einen laufenden Container im JSON-Format an (f√ºhre es selbst aus und schau es dir an). Wir haben das JSON gefiltert, um nur die IP-Adresse des Containers zu erhalten. Wir h√§tten auch den Output mit grep filtern k√∂nnen: docker inspect mariadb-container | grep IPAddress, aber unsere L√∂sung ist eleganter üòä. Sobald du die IP hast (in deinem Beispiel 172.17.0.2), verbinde dich damit: mysql -h172.17.0.2 -uroot -pmy-secret-pw Wenn alles funktioniert, beende den MySQL-Client mit: exit; Hinweis f√ºr Windows Der MySQL-Client muss auf deinem Computer installiert sein. Unter Windows kannst du das Binary aus dem ZIP-Archiv verwenden: https://dev.mysql.com/downloads/mysql/. Auch unter Windows musst du Port-Weiterleitung nutzen, um auf die Datenbank zuzugreifen: docker run --name mariadb-container -p 3306:3306 -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb Jetzt solltest du in der Lage sein, auf die Datenbank zuzugreifen mit: winpty mysql.exe -hlocalhost -uroot -pmy-secret-pw mariadb ü§î Kannst du dir einen anderen Weg vorstellen, auf die Datenbank zuzugreifen? Anstatt den Container mit bash zu betreten, k√∂nnten wir auch direkt MySQL innerhalb des Containers ausf√ºhren: docker exec -it mariadb-container mysql -uroot -pmy-secret-pw ","keywords":"","version":"Next"},{"title":"8. MariaDB-Container verbinden","type":0,"sectionRef":"#","url":"/workshop-container/docs/connect_mariadb","content":"","keywords":"","version":"Next"},{"title":"Vorbereitung der MariaDB-Instanz‚Äã","type":1,"pageTitle":"8. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#vorbereitung-der-mariadb-instanz","content":" Bevor wir unsere Flask-Anwendung erweitern, m√ºssen wir sicherstellen, dass unser MariaDB-Container l√§uft und mit Daten gef√ºllt ist, die wir abfragen k√∂nnen.  ","version":"Next","tagName":"h2"},{"title":"√úberpr√ºfung, ob der MariaDB-Container l√§uft‚Äã","type":1,"pageTitle":"8. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#√ºberpr√ºfung-ob-der-mariadb-container-l√§uft","content":" L√∂sche den alten MariaDB-Container, falls er noch l√§uft:  docker ps docker stop &lt;container-id&gt; docker rm &lt;container-id&gt;   Starte ihn erneut:  docker run --name mariadb-container \\ -v volume-mariadb:/var/lib/mysql \\ -e MARIADB_ROOT_PASSWORD=my-secret-pw \\ -d mariadb   ","version":"Next","tagName":"h3"},{"title":"Bef√ºllen der MariaDB mit Mock-Daten‚Äã","type":1,"pageTitle":"8. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#bef√ºllen-der-mariadb-mit-mock-daten","content":" Verbinde dich mit der MariaDB-Instanz:  docker exec -it mariadb-container mariadb -uroot -pmy-secret-pw   Erstelle eine einfache Tabelle und f√ºge einige Mock-Daten ein:  CREATE DATABASE flaskapp; USE flaskapp; CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, email VARCHAR(255) NOT NULL ); INSERT INTO users (name, email) VALUES ('John Doe', 'john.doe@example.com'), ('Jane Doe', 'jane.doe@example.com');   Verlasse die MariaDB-Shell mit:  exit;   ","version":"Next","tagName":"h3"},{"title":"Erweiterung der Flask-Anwendung‚Äã","type":1,"pageTitle":"8. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#erweiterung-der-flask-anwendung","content":" Um die Flask-Anwendung zu erweitern, damit sie auf die MariaDB-Instanz zugreifen kann, ben√∂tigen wir einen MySQL-Treiber f√ºr Python. Wir werden PyMySQL verwenden.  ","version":"Next","tagName":"h2"},{"title":"Aktualisierung der requirements.txt‚Äã","type":1,"pageTitle":"8. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#aktualisierung-der-requirementstxt","content":" F√ºge PyMySQL zur requirements.txt hinzu:  Flask==3.0.2 PyMySQL==1.1.0   ","version":"Next","tagName":"h3"},{"title":"Aktualisierung der Flask-Anwendung‚Äã","type":1,"pageTitle":"8. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#aktualisierung-der-flask-anwendung","content":" Aktualisiere die app.py, um eine Verbindung zur MariaDB herzustellen und Daten aus der users-Tabelle zu lesen:  from flask import Flask, jsonify import pymysql.cursors app = Flask(__name__) def get_db_connection(): connection = pymysql.connect(host='mariadb-container', user='root', password='my-secret-pw', database='flaskapp', cursorclass=pymysql.cursors.DictCursor) return connection @app.route('/') def users(): connection = get_db_connection() with connection.cursor() as cursor: cursor.execute(&quot;SELECT * FROM users&quot;) users = cursor.fetchall() connection.close() return jsonify(users) if __name__ == '__main__': app.run(debug=True, host='0.0.0.0', port=5000)   ","version":"Next","tagName":"h3"},{"title":"Neubau und Neustart des Flask-Containers‚Äã","type":1,"pageTitle":"8. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#neubau-und-neustart-des-flask-containers","content":" Baue das Docker-Image f√ºr die Anwendung erneut, um die √Ñnderungen zu √ºbernehmen:  docker build -t python-flask-app .   Stoppe und entferne den alten Flask-Container, falls er noch l√§uft:  docker stop python-webapp docker rm python-webapp   Starte den Flask-Container erneut:  docker run -d -p 5000:5000 --name python-webapp --link mariadb-container:mariadb-container python-flask-app   Nun kannst du auf http://localhost:5000 zugreifen, um die Daten aus der MariaDB-Instanz in deiner Flask-Anwendung angezeigt zu bekommen. ","version":"Next","tagName":"h3"},{"title":"Erste Schritte","type":0,"sectionRef":"#","url":"/workshop-container/docs/erste_schritte","content":"","keywords":"","version":"Next"},{"title":"Die Kommandozeile‚Äã","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#die-kommandozeile","content":" Mit Docker installiert und funktionsf√§hig, ist jetzt der richtige Zeitpunkt, dich mit der Befehlszeilenanwendung vertraut zu machen. Die Verwendung von Docker besteht darin, mindestens einen Befehl zu verwenden. docker --help zeigt die verf√ºgbaren Optionen.  docker --help   Usage: docker COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default &quot;/home/user/.docker&quot;) -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default &quot;/home/user/.docker/ca.pem&quot;) --tlscert string Path to TLS certificate file (default &quot;/home/user/.docker/cert.pem&quot;) --tlskey string Path to TLS key file (default &quot;/home/user/.docker/key.pem&quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quit Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes Run 'docker COMMAND --help' for more information on a command.   Um die f√ºr einen spezifischen Befehl verf√ºgbaren Schalter zu sehen, tippe:  docker &lt;command&gt; --help   Um systemweite Informationen √ºber Docker zu sehen, benutze:  docker info   ","version":"Next","tagName":"h2"},{"title":"Hello World (mit Docker)‚Äã","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#hello-world-mit-docker","content":" Docker-Container werden aus Docker-Images ausgef√ºhrt. Standardm√§√üig ziehen sie diese Images von Docker Hub, einer Docker-Registry, die von Docker Inc, dem Unternehmen hinter dem Docker-Projekt, verwaltet wird. Jeder kann seine Docker-Images auf Docker Hub erstellen und hosten, daher findest du f√ºr viele Anwendungen und Linux-Distributionen Docker-Images, die auf Docker Hub gehostet werden.  Um zu √ºberpr√ºfen, ob du auf Docker Hub zugreifen und Images herunterladen kannst, tippe:  docker run hello-world   Die Ausgabe, die Folgendes beinhalten sollte, deutet darauf hin, dass Docker korrekt zu funktionieren scheint:  Hello from Docker. This message shows that your installation appears to be working correctly. ...   ","version":"Next","tagName":"h2"},{"title":"Dein erster Container üéâ‚Äã","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#dein-erster-container-","content":" Mit diesem Befehl haben wir gerade unseren ersten Container auf unserem Computer ausgef√ºhrt. Er f√ºhrte einen einfachen Prozess aus, der eine Nachricht auf der Standardausgabe ausgab, der Container selbst ist jedoch nicht sehr n√ºtzlich.  Docker Dokumentation  Besuche https://docs.docker.com und mache dich mit den Dokumentationen sowie den Referenzen vertraut. In diesem Training verwenden wir Docker CE, daher k√∂nnte es auch sinnvoll sein, diesen Abschnitt in der Dokumentation zu √ºberpr√ºfen.  Frage: Muss ich den Namen des Docker Images auswendig kennen? Nein! Es gibt Unmengen von Images, die von Unternehmen, Open-Source-Projekten und Einzelpersonen bereitgestellt werden. Du kannst diese Images in verschiedenen Registries suchen, einige der bekannteren sind Docker Hub und Github Container Registry. Sieh dir das n√§chste Lab f√ºr weitere Details an. ","version":"Next","tagName":"h2"},{"title":"7. Eigener Container bereitstellen","type":0,"sectionRef":"#","url":"/workshop-container/docs/frontend_container","content":"","keywords":"","version":"Next"},{"title":"Eine Python-Webanwendung als Frontend-Container bereitstellen‚Äã","type":1,"pageTitle":"7. Eigener Container bereitstellen","url":"/workshop-container/docs/frontend_container#eine-python-webanwendung-als-frontend-container-bereitstellen","content":" Zuerst m√ºssen wir das passende Docker-Image finden --&gt; Wo? Genau... auf Docker Hub.  Verwende das Image python:3.12-slim als Basis, um eine einfache Python-Webanwendung mit Flask zu deployen.  docker pull python:3.12-slim   Sobald das Image heruntergeladen wurde, kannst du deine lokalen docker images √ºberpr√ºfen:  docker images   Dies zeigt die Images im lokalen Register mit ihrem Namen und Tags an.  Als N√§chstes bereiten wir einen einfachen Flask-Webserver vor. Erstelle daf√ºr eine Datei namens app.py mit folgendem Inhalt:  from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World von Flask!' if __name__ == '__main__': app.run(debug=True, host='0.0.0.0')   Zus√§tzlich ben√∂tigst du eine requirements.txt-Datei f√ºr Flask:  Flask==3.0.2   Erstelle ein Dockerfile, um die App und ihre Abh√§ngigkeiten in ein Image zu packen:  FROM python:3.12-slim WORKDIR /app COPY requirements.txt requirements.txt RUN pip install -r requirements.txt COPY . . CMD [&quot;python&quot;, &quot;app.py&quot;]   Baue das Docker-Image f√ºr die Anwendung:  docker build -t python-flask-app .   Nun deploye den neuen Container mit dem soeben erstellten Image:  docker run -d -p 5000:5000 --name python-webapp python-flask-app   docker ps zeigt alle laufenden Container. √úberpr√ºfe, ob python-webapp l√§uft:  docker ps   Nun kannst du versuchen, dich mit dem Server √ºber die zugewiesene Docker-IP-Adresse zu verbinden oder, falls du Portweiterleitung verwendet hast, direkt √ºber http://localhost:5000.  Wenn du innerhalb einer Umgebung ohne direkten Browserzugriff arbeitest (z.B. Webshell), kannst du curl http://localhost:5000 verwenden, um die Seite in deinem Terminal zu √∂ffnen.  Hinweis f√ºr Windows und macOS Wenn du unter Windows oder macOS arbeitest und den Container bereits gestartet hast, solltest du in der Lage sein, direkt √ºber http://localhost:5000 auf die Webanwendung zuzugreifen, dank der Portweiterleitung, die im docker run-Befehl definiert wurde.  Damit hast du erfolgreich einen Frontend-Container mit einer Python-Webanwendung deployt, die auf Flask basiert. ","version":"Next","tagName":"h2"},{"title":"Einf√ºhrung","type":0,"sectionRef":"#","url":"/workshop-container/docs/intro","content":"Einf√ºhrung In diesem Training wirst du die Grundlagen hinter der Containertechnologie Docker lernen. Was sind Container?Docker auf deinem Computer installierenDocker-Container ausf√ºhrenLokale Volumes in Container einbindenDocker-Container erstellenWie Netzwerken funktioniert Zus√§tzliche Unterlagen Offizielle Docker Dokumentation","keywords":"","version":"Next"},{"title":"Docker Images","type":0,"sectionRef":"#","url":"/workshop-container/docs/images","content":"Docker Images Du kannst nach auf Docker Hub verf√ºgbaren Images suchen, indem du auf den Link &quot;Explore&quot; klickst oder &quot;mariadb&quot; in das Suchfeld eingibst:https://hub.docker.com/search/?q=mariadb&amp;type=image Du erh√§ltst eine Liste mit Ergebnissen und der erste Treffer wird wahrscheinlich das offizielle Image sein: https://hub.docker.com/_/mariadb Diese Seite enth√§lt Anweisungen, wie das Image abgerufen werden kann. Lass uns das machen: docker pull mariadb Hinweis Achte auf Sicherheit! √úberpr√ºfe die Images, bevor du sie ausf√ºhrst. Ist es ein offizielles Image?Was ist in dem Image installiert? Lies das Dockerfile, das zum Erstellen des Images verwendet wurde√úberpr√ºfe das Basis-Image Nachdem ein Image heruntergeladen wurde, kannst du dann einen Container mit dem heruntergeladenen Image mit dem Unterbefehl run ausf√ºhren. Wenn ein Image nicht heruntergeladen wurde, wenn Docker mit dem Unterbefehl run ausgef√ºhrt wird, wird der Docker-Client zuerst das Image herunterladen und dann einen Container damit ausf√ºhren: docker run mariadb:latest Hinweis Hier verwenden wir das latest Tag, um die neueste Version des Images zu verwenden. Es ist jedoch eine gute Praxis, ein spezifisches Tag zu verwenden, um sicherzustellen, dass du immer die gleiche Version des Images verwendest. Um die Images zu sehen, die auf deinen Computer heruntergeladen wurden, gib ein: docker images Die Ausgabe sollte √§hnlich wie folgt aussehen: REPOSITORY TAG IMAGE ID CREATED SIZE mariadb latest 58730544b81b 2 weeks ago 397MB hello-world latest 1815c82652c0 2 months ago 1.84kB hello-world linux 1815c82652c0 2 months ago 1.84kB Der Hello-World-Container, den du im vorherigen Lab ausgef√ºhrt hast, ist ein Beispiel f√ºr einen Container, der l√§uft und beendet wird, nachdem er eine Testnachricht ausgegeben hat. Container k√∂nnen jedoch viel n√ºtzlicher sein und sie k√∂nnen interaktiv sein. Schlie√ülich sind sie √§hnlich wie virtuelle Maschinen, nur ressourcenfreundlicher. Als Beispiel f√ºhren wir einen Container mit dem neuesten Image von MariaDB aus. Die Kombination der Schalter -i und -t gibt dir interaktiven Shell-Zugriff auf den Container: docker run -it mariadb:latest Hinweis f√ºr Windows Wenn du git-bash, cmd oder powershell auf einem Windows-System verwendest, achte auf den Fehler: the input device is not a TTY. If you are using mintty, try prefixing the command with 'winpty' Setze winpty am Anfang jedes Befehls, der die -it Parameter verwendet. Zum Beispiel: winpty docker run -it mariadb:latest Ein Fehler ist aufgetaucht! 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:11.2.2+maria~ubu2204 started. 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql' 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:11.2.2+maria~ubu2204 started. 2024-02-09 11:44:31+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ROOT_PASSWORD_HASH, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD ü§î Warum ist dieser Fehler aufgetreten? Ist es ein Bug im Image? Alles ist in Ordnung, um dieses Image auszuf√ºhren, ist eine gewisse Konfiguration erforderlich. Lies den folgenden Auszug sorgf√§ltig durch. error: database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD ü§î Was ist ein Image? Denke an ein Image wie an einen Bauplan, der verwendet wird, um Container zu erstellen. Ein Image ist eine Sammlung von Dateien + einigen Metadaten (oder in technischen Begriffen: diese Dateien bilden das Root-Dateisystem eines Containers)Images bestehen aus Schichten, die konzeptionell √ºbereinander gestapelt sindJede Schicht kann Dateien hinzuf√ºgen, ver√§ndern oder entfernenImages k√∂nnen Schichten teilen, um die Nutzung von Festplattenspeicher, √úbertragungszeiten und Speichernutzung zu optimierenDu baust diese Images mit Hilfe von Dockerfiles (in sp√§teren Labs)Images sind unver√§nderlich, du kannst sie nach der Erstellung nicht √§ndern ü§î Was ist der Unterschied zwischen einem Container und einem Image? Wenn du ein Image ausf√ºhrst, wird es zu einem Container. Ein Image ist ein schreibgesch√ºtztes DateisystemEin Container ist ein eingekapselter Satz von Prozessen, der in einer schreibbaren Kopie dieses Dateisystems l√§uftdocker run startet einen Container aus einem gegebenen Image","keywords":"","version":"Next"},{"title":"6. Volumes","type":0,"sectionRef":"#","url":"/workshop-container/docs/volumes","content":"","keywords":"","version":"Next"},{"title":"Ein Volume in einem Container einbinden‚Äã","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#ein-volume-in-einem-container-einbinden","content":" Der MariaDB-Container ist ein gutes Beispiel daf√ºr, warum es gut ist, ein externes Volume zu haben. Es gibt mehrere M√∂glichkeiten, wie man mit Volumes in Docker arbeiten kann, in diesem Fall werden wir ein von Docker verwaltetes Volume erstellen, um die persistenten Daten unserer MariaDB zu speichern. Das Volume wird von Docker selbst verwaltet.  Erstelle das von Docker verwaltete Volume mit:  docker volume create volume-mariadb   Nun benutze das erstellte Volume und h√§nge es an die MariaDB-Datenbank an.  Mit dem Parameter -v das Volume an einen Pfad im Container anh√§ngen:  docker run --name mariadb-container-with-external-volume -v volume-mariadb:/var/lib/mysql -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb   Siehe Dokumentation zu Docker-Volumes f√ºr mehr Informationen.  Okay, nun erstelle einen neuen Benutzer im MariaDB-Container:  docker exec -it mariadb-container-with-external-volume mariadb -uroot -pmy-secret-pw   Im mariadb-Client f√ºhre einige SQL-Befehle aus:  use mysql CREATE USER 'peter'@'%' IDENTIFIED BY 'venkman'; GRANT SELECT ON * . * TO 'peter'@'%';   Sobald alle Schritte abgeschlossen sind, beende die MySQL-Sitzung und verlasse den Container:  exit;   Um zu testen, ob Peter korrekt erstellt wurde, einfach mit seinen Anmeldedaten einloggen.  Nun stoppe und entferne den mariadb-container-with-external-volume Container.  docker stop mariadb-container-with-external-volume docker rm mariadb-container-with-external-volume   Als N√§chstes √ºberpr√ºfe, ob die Daten noch verf√ºgbar sind. Erstelle einen neuen MariaDB-Container mit dem vorherigen Volume:  docker run --name mariadb-container-with-existing-external-volume \\ -v volume-mariadb:/var/lib/mysql \\ -e MARIADB_ROOT_PASSWORD=my-secret-pw \\ -d mariadb   Der Moment der Wahrheit... Verbinde dich mit dem Datenbankserver mit Peters Anmeldedaten:  docker exec -it mariadb-container-with-existing-external-volume mariadb -upeter -pvenkman   Du solltest nun als peter mit deiner Datenbankinstanz verbunden sein. Du kannst dies testen, indem du die Benutzer mit dem SQL-Client auflistest:  SELECT User FROM mysql.user;   +-----------------+ | USER() | +-----------------+ | peter@localhost | +-----------------+ 1 Zeile in Satz (0.00 Sek.)   Jetzt verlasse den MySQL-Client  exit;   ","version":"Next","tagName":"h2"},{"title":"Zus√§tzliche Infos zur Arbeit mit Docker-Volumes‚Äã","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#zus√§tzliche-infos-zur-arbeit-mit-docker-volumes","content":" Docker-Volumes k√∂nnen verwendet werden f√ºr:  Entkoppeln der gespeicherten Daten vom Container, der die Daten erstellt hatUmgehen des Copy-on-Write-Systems, um native Festplatten-I/O-Leistung zu erzielenUmgehen von Copy-on-Write, um einige Dateien aus dem Docker-Commit auszuschliessenTeilen eines Verzeichnisses zwischen mehreren ContainernTeilen eines Verzeichnisses zwischen dem Host und einem ContainerTeilen einer einzelnen Datei zwischen dem Host und einem Container Eine Alternative zur Arbeit mit Volumes w√§re das Einbinden lokaler Verzeichnisse (Host-Ordner) √ºber einen Pfad in deinen Container. Dies werden wir in Kapitel 08 verwenden.  ","version":"Next","tagName":"h2"},{"title":"Docker-Speichertreiber‚Äã","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#docker-speichertreiber","content":" Wenn du viele Docker-Container auf einer Maschine betreibst, ben√∂tigst du normalerweise viel Speicher. Docker-Volumes und Container-Speicher werden auf einem Dateisystem bereitgestellt. Der folgende Link bietet zus√§tzliche Informationen dar√ºber, wie du das richtige Speichersetup ausw√§hlst:  https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/managing_containers/managing_storage_with_docker_formatted_containers  Derzeit ist overlay2 der empfohlene Speichertreiber. ","version":"Next","tagName":"h3"},{"title":"Umgebungsvariablen (Environment Variables)","type":0,"sectionRef":"#","url":"/workshop-container/docs/umgebungs_variablen","content":"","keywords":"","version":"Next"},{"title":"Detached Containers‚Äã","type":1,"pageTitle":"Umgebungsvariablen (Environment Variables)","url":"/workshop-container/docs/umgebungs_variablen#detached-containers","content":" Es gibt eine M√∂glichkeit, Container im Hintergrund laufen zu lassen, ohne dass sie die Shell blockieren. Daf√ºr musst du den Parameter -d verwenden, z.B.:  docker run -d -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb   Wenn du den Befehl ausf√ºhrst, wirst du eine Ausgabe wie diese sehen:  1a84e2e51ff2   Das ist die ID des Containers, die du verwenden kannst, um auf den Container zuzugreifen oder ihn zu stoppen. Wenn du nun alle laufenden Container sehen m√∂chtest, verwende den folgenden Befehl:  docker ps   Die Ausgabe sollte √§hnlich wie folgt aussehen:  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1a84e2e51ff2 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 3 minutes ago Up 3 minutes 3306/tcp amazing_mendeleev  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}