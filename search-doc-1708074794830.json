{"searchDocs":[{"title":"Container lÃ¶schen","type":0,"sectionRef":"#","url":"/workshop-container/docs/container_loeschen","content":"Container lÃ¶schen Es gibt zwei MÃ¶glichkeiten einen Container zu lÃ¶schen. Wir starten mit dem einfachsten Weg, um einen Container zu lÃ¶schen. Zuerst musst du den Namen oder die ID des Containers herausfinden, den du lÃ¶schen mÃ¶chtest. docker ps Die Ausgabe sollte Ã¤hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.sâ€¦&quot; 9 minutes ago Up 9 minutes 3306/tcp focused_noether In diesem Beispiel ist der Name des Containers focused_noether. Um den Container zu lÃ¶schen, gib ein: docker stop focused_noether Jetzt kannst du Ã¼berprÃ¼fen, ob der Container gestoppt ist, indem du den folgenden Befehl eingibst: docker ps -a Die Ausgabe sollte Ã¤hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.sâ€¦&quot; 9 minutes ago Exited (0) 2 minutes ago focused_noether Wir haben somit den container &quot;gracefully&quot; gestoppt, aber es gibt auch die MÃ¶glichkeit, einen Container &quot;forcefully&quot; zu stoppen. Dazu gibst du den folgenden Befehl ein: docker kill focused_noether Wenn der Container gestoppt ist, kannst du ihn lÃ¶schen, indem du den folgenden Befehl eingibst: docker rm focused_noether Hinweis Es ist eine gute Praxis, Container zu lÃ¶schen, die nicht mehr benÃ¶tigt werden, um Speicherplatz freizugeben. ğŸ¤” Wo kommen diese komischen Namen der Container her? Docker generiert automatisch Namen fÃ¼r Container, wenn du keinen Namen angibst. Das ist nÃ¼tzlich, wenn du viele Container auf deinem Computer ausfÃ¼hrst und nicht jedes Mal einen Namen ausdenken mÃ¶chtest. Wie du einen Container mit einem Namen erstellst, erfÃ¤hrst du im nÃ¤chsten Lab.","keywords":"","version":"Next"},{"title":"Benennen von Containern","type":0,"sectionRef":"#","url":"/workshop-container/docs/container_name","content":"Benennen von Containern Im Gegensatz zur CONTAINER ID ist der NAME etwas, das wir manipulieren kÃ¶nnen. Der Name ist praktisch, nicht nur zum Starten/Verbinden/Stoppen/ZerstÃ¶ren eines Containers, sondern auch fÃ¼r das Networking (was wir in einem spÃ¤teren Lab sehen werden). Um einen Namen zu setzen, fÃ¼ge den Parameter --name zum run Befehl von Docker hinzu: docker run --name mariadb-container -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb Wie immer, um zu Ã¼berprÃ¼fen, ob dies wirklich funktioniert hat, schau dir die Container-Liste an: docker ps Die Ausgabe sollte Ã¤hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.sâ€¦&quot; 9 minutes ago Up 9 minutes 3306/tcp mariadb-container Anstatt wie im letzten Lab auf die Datenbank von innerhalb des Containers zuzugreifen, greifen wir von aussen mit einem lokalen mysqlclient darauf zu. Das ist ein bisschen knifflig. Zuerst musst du die IP-Adresse deines Docker-Containers herausfinden. DafÃ¼r verwendest du diesen Befehl: docker inspect mariadb-container -f '{{ range.NetworkSettings.Networks }}{{ .IPAddress }}{{ end }}' docker inspect &lt;container&gt; zeigt dir Details Ã¼ber einen laufenden Container im JSON-Format an (fÃ¼hre es selbst aus und schau es dir an). Wir haben das JSON gefiltert, um nur die IP-Adresse des Containers zu erhalten. Wir hÃ¤tten auch den Output mit grep filtern kÃ¶nnen: docker inspect mariadb-container | grep IPAddress, aber unsere LÃ¶sung ist eleganter ğŸ˜Š. Sobald du die IP hast (in deinem Beispiel 172.17.0.2), verbinde dich damit: mysql -h172.17.0.2 -uroot -pmy-secret-pw Wenn alles funktioniert, beende den MySQL-Client mit: exit; Hinweis fÃ¼r Windows Der MySQL-Client muss auf deinem Computer installiert sein. Unter Windows kannst du das Binary aus dem ZIP-Archiv verwenden: https://dev.mysql.com/downloads/mysql/. Auch unter Windows musst du Port-Weiterleitung nutzen, um auf die Datenbank zuzugreifen: docker run --name mariadb-container -p 3306:3306 -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb Jetzt solltest du in der Lage sein, auf die Datenbank zuzugreifen mit: winpty mysql.exe -hlocalhost -uroot -pmy-secret-pw mariadb ğŸ¤” Kannst du dir einen anderen Weg vorstellen, auf die Datenbank zuzugreifen? Anstatt den Container mit bash zu betreten, kÃ¶nnten wir auch direkt MySQL innerhalb des Containers ausfÃ¼hren: docker exec -it mariadb-container mysql -uroot -pmy-secret-pw ","keywords":"","version":"Next"},{"title":"9. MariaDB-Container verbinden","type":0,"sectionRef":"#","url":"/workshop-container/docs/connect_mariadb","content":"","keywords":"","version":"Next"},{"title":"Vorbereitung der MariaDB-Instanzâ€‹","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#vorbereitung-der-mariadb-instanz","content":" Bevor wir unsere Flask-Anwendung erweitern, mÃ¼ssen wir sicherstellen, dass unser MariaDB-Container lÃ¤uft und mit Daten gefÃ¼llt ist, die wir abfragen kÃ¶nnen.  ","version":"Next","tagName":"h2"},{"title":"ÃœberprÃ¼fung, ob der MariaDB-Container lÃ¤uftâ€‹","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#Ã¼berprÃ¼fung-ob-der-mariadb-container-lÃ¤uft","content":" LÃ¶sche den alten MariaDB-Container, falls er noch lÃ¤uft:  docker ps docker stop &lt;container-id&gt; docker rm &lt;container-id&gt;   Starte ihn erneut:  docker run --name mariadb-container \\ -v volume-mariadb:/var/lib/mysql \\ -e MARIADB_ROOT_PASSWORD=my-secret-pw \\ -d mariadb   ","version":"Next","tagName":"h3"},{"title":"BefÃ¼llen der MariaDB mit Mock-Datenâ€‹","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#befÃ¼llen-der-mariadb-mit-mock-daten","content":" Verbinde dich mit der MariaDB-Instanz:  docker exec -it mariadb-container mariadb -uroot -pmy-secret-pw   Erstelle eine einfache Tabelle und fÃ¼ge einige Mock-Daten ein:  CREATE DATABASE flaskapp; USE flaskapp; CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, email VARCHAR(255) NOT NULL ); INSERT INTO users (name, email) VALUES ('John Doe', 'john.doe@example.com'), ('Jane Doe', 'jane.doe@example.com');   Verlasse die MariaDB-Shell mit:  exit;   ","version":"Next","tagName":"h3"},{"title":"Erweiterung der Flask-Anwendungâ€‹","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#erweiterung-der-flask-anwendung","content":" Um die Flask-Anwendung zu erweitern, damit sie auf die MariaDB-Instanz zugreifen kann, benÃ¶tigen wir einen MySQL-Treiber fÃ¼r Python. Wir werden PyMySQL verwenden.  ","version":"Next","tagName":"h2"},{"title":"Aktualisierung der requirements.txtâ€‹","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#aktualisierung-der-requirementstxt","content":" FÃ¼ge PyMySQL zur requirements.txt hinzu:  requirements.txt Flask==3.0.2 PyMySQL==1.1.0   ","version":"Next","tagName":"h3"},{"title":"Aktualisierung der Flask-Anwendungâ€‹","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#aktualisierung-der-flask-anwendung","content":" Aktualisiere die app.py, um eine Verbindung zur MariaDB herzustellen und Daten aus der users-Tabelle zu lesen:  app.py from flask import Flask, jsonify import pymysql.cursors app = Flask(__name__) def get_db_connection(): connection = pymysql.connect(host='mariadb-container', user='root', password='my-secret-pw', database='flaskapp', cursorclass=pymysql.cursors.DictCursor) return connection @app.route('/') def users(): connection = get_db_connection() with connection.cursor() as cursor: cursor.execute(&quot;SELECT * FROM users&quot;) users = cursor.fetchall() connection.close() return jsonify(users) if __name__ == '__main__': app.run(debug=True, host='0.0.0.0', port=5000)   ","version":"Next","tagName":"h3"},{"title":"Neubau und Neustart des Flask-Containersâ€‹","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#neubau-und-neustart-des-flask-containers","content":" Baue das Docker-Image fÃ¼r die Anwendung erneut, um die Ã„nderungen zu Ã¼bernehmen:  docker build -t python-flask-app .   Stoppe und entferne den alten Flask-Container, falls er noch lÃ¤uft:  docker stop python-webapp docker rm python-webapp   Starte den Flask-Container erneut:  docker run -d -p 5000:5000 --name python-webapp --link mariadb-container:mariadb-container python-flask-app   Nun kannst du auf http://localhost:5000 zugreifen, um die Daten aus der MariaDB-Instanz in deiner Flask-Anwendung angezeigt zu bekommen. ","version":"Next","tagName":"h3"},{"title":"Erste Schritte","type":0,"sectionRef":"#","url":"/workshop-container/docs/erste_schritte","content":"","keywords":"","version":"Next"},{"title":"Die Kommandozeileâ€‹","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#die-kommandozeile","content":" Mit Docker installiert und funktionsfÃ¤hig, ist jetzt der richtige Zeitpunkt, dich mit der Befehlszeilenanwendung vertraut zu machen. Die Verwendung von Docker besteht darin, mindestens einen Befehl zu verwenden. docker --help zeigt die verfÃ¼gbaren Optionen.  docker --help   Usage: docker COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default &quot;/home/user/.docker&quot;) -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default &quot;/home/user/.docker/ca.pem&quot;) --tlscert string Path to TLS certificate file (default &quot;/home/user/.docker/cert.pem&quot;) --tlskey string Path to TLS key file (default &quot;/home/user/.docker/key.pem&quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quit Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes Run 'docker COMMAND --help' for more information on a command.   Um die fÃ¼r einen spezifischen Befehl verfÃ¼gbaren Schalter zu sehen, tippe:  docker &lt;command&gt; --help   Um systemweite Informationen Ã¼ber Docker zu sehen, benutze:  docker info   ","version":"Next","tagName":"h2"},{"title":"Hello World (mit Docker)â€‹","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#hello-world-mit-docker","content":" Docker-Container werden aus Docker-Images ausgefÃ¼hrt. StandardmÃ¤ÃŸig ziehen sie diese Images von Docker Hub, einer Docker-Registry, die von Docker Inc, dem Unternehmen hinter dem Docker-Projekt, verwaltet wird. Jeder kann seine Docker-Images auf Docker Hub erstellen und hosten, daher findest du fÃ¼r viele Anwendungen und Linux-Distributionen Docker-Images, die auf Docker Hub gehostet werden.  Um zu Ã¼berprÃ¼fen, ob du auf Docker Hub zugreifen und Images herunterladen kannst, tippe:  docker run hello-world   Die Ausgabe, die Folgendes beinhalten sollte, deutet darauf hin, dass Docker korrekt zu funktionieren scheint:  Hello from Docker. This message shows that your installation appears to be working correctly. ...   ","version":"Next","tagName":"h2"},{"title":"Dein erster Container ğŸ‰â€‹","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#dein-erster-container-","content":" Mit diesem Befehl haben wir gerade unseren ersten Container auf unserem Computer ausgefÃ¼hrt. Er fÃ¼hrte einen einfachen Prozess aus, der eine Nachricht auf der Standardausgabe ausgab, der Container selbst ist jedoch nicht sehr nÃ¼tzlich.  Docker Dokumentation  Besuche https://docs.docker.com und mache dich mit den Dokumentationen sowie den Referenzen vertraut. In diesem Training verwenden wir Docker CE, daher kÃ¶nnte es auch sinnvoll sein, diesen Abschnitt in der Dokumentation zu Ã¼berprÃ¼fen.  Frage: Muss ich den Namen des Docker Images auswendig kennen? Nein! Es gibt Unmengen von Images, die von Unternehmen, Open-Source-Projekten und Einzelpersonen bereitgestellt werden. Du kannst diese Images in verschiedenen Registries suchen, einige der bekannteren sind Docker Hub und Github Container Registry. Sieh dir das nÃ¤chste Lab fÃ¼r weitere Details an. ","version":"Next","tagName":"h2"},{"title":"7. Eigener Container bereitstellen","type":0,"sectionRef":"#","url":"/workshop-container/docs/frontend_container","content":"","keywords":"","version":"Next"},{"title":"Eine Python-Webanwendung als Frontend-Container bereitstellenâ€‹","type":1,"pageTitle":"7. Eigener Container bereitstellen","url":"/workshop-container/docs/frontend_container#eine-python-webanwendung-als-frontend-container-bereitstellen","content":" Zuerst mÃ¼ssen wir das passende Docker-Image finden --&gt; Wo? Genau... auf Docker Hub.  Verwende das Image python:3.12-slim als Basis, um eine einfache Python-Webanwendung mit Flask zu deployen.  docker pull python:3.12-slim   Sobald das Image heruntergeladen wurde, kannst du deine lokalen docker images Ã¼berprÃ¼fen:  docker images   Dies zeigt die Images im lokalen Register mit ihrem Namen und Tags an.  Als NÃ¤chstes bereiten wir einen einfachen Flask-Webserver vor. Erstelle dafÃ¼r eine Datei namens app.py mit folgendem Inhalt:  app.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World von Flask!' if __name__ == '__main__': app.run(debug=True, host='0.0.0.0')   ZusÃ¤tzlich benÃ¶tigst du eine requirements.txt-Datei fÃ¼r Flask:  requirements.txt Flask==3.0.2   Erstelle ein Dockerfile, um die App und ihre AbhÃ¤ngigkeiten in ein Image zu packen:  Dockerfile FROM python:3.12-slim WORKDIR /app COPY requirements.txt requirements.txt RUN pip install -r requirements.txt COPY . . CMD [&quot;python&quot;, &quot;app.py&quot;]   Baue das Docker-Image fÃ¼r die Anwendung:  docker build -t python-flask-app .   Nun deploye den neuen Container mit dem soeben erstellten Image:  docker run -d -p 5000:5000 --name python-webapp python-flask-app   docker ps zeigt alle laufenden Container. ÃœberprÃ¼fe, ob python-webapp lÃ¤uft:  docker ps   Nun kannst du versuchen, dich mit dem Server Ã¼ber die zugewiesene Docker-IP-Adresse zu verbinden oder, falls du Portweiterleitung verwendet hast, direkt Ã¼ber http://localhost:5000.  Wenn du innerhalb einer Umgebung ohne direkten Browserzugriff arbeitest (z.B. Webshell), kannst du curl http://localhost:5000 verwenden, um die Seite in deinem Terminal zu Ã¶ffnen.  Hinweis fÃ¼r Windows und macOS Wenn du unter Windows oder macOS arbeitest und den Container bereits gestartet hast, solltest du in der Lage sein, direkt Ã¼ber http://localhost:5000 auf die Webanwendung zuzugreifen, dank der Portweiterleitung, die im docker run-Befehl definiert wurde.  Damit hast du erfolgreich einen Frontend-Container mit einer Python-Webanwendung deployt, die auf Flask basiert.  Im nÃ¤chsten Lab lernst du, wie genau ein Container Image erstellt wird. ","version":"Next","tagName":"h2"},{"title":"Debugging von Containern","type":0,"sectionRef":"#","url":"/workshop-container/docs/debugging","content":"","keywords":"","version":"Next"},{"title":"Docker-Systeminformationenâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#docker-systeminformationen","content":" Um einen umfassenden Ãœberblick Ã¼ber den Zustand und die Konfiguration deiner Docker-Installation zu erhalten, kannst du den Befehl docker info verwenden. Dies liefert detaillierte Informationen Ã¼ber die Anzahl der Container, Images, die Serverversion, verwendete Treiber und vieles mehr. Ein Beispieloutput kÃ¶nnte so aussehen:  docker info   Containers: 42 Running: 0 Paused: 0 Stopped: 42 Images: 75 Server Version: 18.06.1-ce ...   ","version":"Next","tagName":"h2"},{"title":"Container auflistenâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-auflisten","content":" Um den aktuellen Status deiner Container zu Ã¼berprÃ¼fen, kannst du verschiedene Varianten des docker ps Befehls verwenden:  Laufende Container anzeigen: Der Standardbefehl docker ps zeigt alle aktuell laufenden Container an. Alle Container anzeigen: Mit docker ps -a erhÃ¤ltst du eine Liste aller Container, einschliesslich der gestoppten. Den letzten Container anzeigen: docker ps -l zeigt den zuletzt gestarteten Container an. Nur IDs laufender Container anzeigen: Mit docker ps -q kannst du schnell die IDs aller laufenden Container abrufen. ContainergrÃ¶ssen anzeigen: docker ps -s gibt zusÃ¤tzlich die GrÃ¶sse der Container aus.  Hinweis docker container ls ist ein Ã¤quivalenter Befehl zu docker ps und kann ebenfalls verwendet werden, um Container zu listen.  ","version":"Next","tagName":"h2"},{"title":"Ressourcennutzung Ã¼berwachenâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#ressourcennutzung-Ã¼berwachen","content":" Speicher- und CPU-Verbrauch: Der Befehl docker stats liefert Echtzeitdaten zum Ressourcenverbrauch aller laufenden Container. Speicherverteilung anzeigen: docker system df zeigt die Speichernutzung durch Container, Images und Volumes an.  ","version":"Next","tagName":"h2"},{"title":"Container-Logsâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-logs","content":" Um Einblicke in die AktivitÃ¤ten eines Containers zu erhalten, kannst du die Logs mit docker logs &lt;container&gt; abrufen. Dies ist besonders nÃ¼tzlich, um Fehlermeldungen oder andere Ausgaben der Anwendung zu Ã¼berprÃ¼fen.  ","version":"Next","tagName":"h2"},{"title":"Container inspizierenâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-inspizieren","content":" FÃ¼r eine detaillierte Ansicht der Konfiguration und des Zustands eines Containers nutze docker inspect &lt;container&gt;. Dieser Befehl liefert JSON-formatierte Daten zu Netzwerkeinstellungen, Volumes und vielem mehr.  ","version":"Next","tagName":"h2"},{"title":"In Container eintretenâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#in-container-eintreten","content":" Um Befehle innerhalb eines laufenden Containers auszufÃ¼hren oder eine interaktive Shell zu starten, verwende docker exec -it &lt;container&gt; /bin/bash (oder /bin/sh fÃ¼r leichtgewichtigere Images).  ","version":"Next","tagName":"h2"},{"title":"Prozesse im Container anzeigenâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#prozesse-im-container-anzeigen","content":" docker top &lt;container&gt; zeigt die aktuell im Container laufenden Prozesse an, Ã¤hnlich dem top Befehl in Unix-basierten Systemen.  ","version":"Next","tagName":"h2"},{"title":"DateiÃ¤nderungen verfolgenâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#dateiÃ¤nderungen-verfolgen","content":" Mit docker diff &lt;container&gt; kannst du Ã„nderungen an den Dateien im Container seit dessen Start identifizieren. Dies umfasst hinzugefÃ¼gte, geÃ¤nderte und gelÃ¶schte Dateien.  ","version":"Next","tagName":"h2"},{"title":"Image-Historieâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#image-historie","content":" Der Befehl docker history &lt;image&gt; gibt Auskunft Ã¼ber die Schichten eines Images und kann helfen zu verstehen, wie ein Image aufgebaut wurde.  ","version":"Next","tagName":"h2"},{"title":"Container-Eventsâ€‹","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-events","content":" Um eine Chronik von Events, die einen bestimmten Container betreffen, zu sehen, nutze docker events &lt;container&gt;. Dies kann bei der Diagnose von Start- oder Netzwerkproblemen hilfreich sein.  Mit diesen Werkzeugen und Techniken bist du gut gerÃ¼stet, um die hÃ¤ufigsten Probleme bei der Arbeit mit Docker-Containern zu diagnostizieren und zu beheben. ","version":"Next","tagName":"h2"},{"title":"8.1 Mehrstufiger Build","type":0,"sectionRef":"#","url":"/workshop-container/docs/image_build/08_01_multistage_build","content":"","keywords":"","version":"Next"},{"title":"EinfÃ¼hrung in Multistage Buildsâ€‹","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#einfÃ¼hrung-in-multistage-builds","content":" Das Ziel eines Multistage Builds ist es, die GrÃ¶ÃŸe des finalen Images zu minimieren und die Sicherheit zu erhÃ¶hen, indem nur die notwendigen AbhÃ¤ngigkeiten und Artefakte im finalen Image enthalten sind. Dies ist besonders nÃ¼tzlich in Sprachen und Umgebungen, in denen der Build-Prozess AbhÃ¤ngigkeiten und Tools benÃ¶tigt, die zur Laufzeit nicht erforderlich sind.  ","version":"Next","tagName":"h2"},{"title":"Beispiel: Optimierung des Python-App-Imagesâ€‹","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#beispiel-optimierung-des-python-app-images","content":" Angenommen, wir haben eine Python-Webanwendung entwickelt, die wir in einem Docker-Container deployen mÃ¶chten. Der Build-Prozess fÃ¼r die Anwendung erfordert verschiedene AbhÃ¤ngigkeiten, aber fÃ¼r die AusfÃ¼hrung der Anwendung sind nicht alle Build-AbhÃ¤ngigkeiten notwendig.  ","version":"Next","tagName":"h2"},{"title":"Dockerfile vor der Optimierungâ€‹","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#dockerfile-vor-der-optimierung","content":" Das ursprÃ¼ngliche Dockerfile kÃ¶nnte folgendermaÃŸen aussehen:  FROM python:3.12-slim WORKDIR /app COPY ./python-app/ /app/ RUN pip install -r requirements.txt CMD [&quot;python&quot;, &quot;app.py&quot;]   ","version":"Next","tagName":"h3"},{"title":"Dockerfile nach der Optimierung mit Multistage Buildâ€‹","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#dockerfile-nach-der-optimierung-mit-multistage-build","content":" Wir kÃ¶nnen das Dockerfile optimieren, indem wir einen Multistage Build verwenden:  Dockerfile # Build-Stage FROM python:3.12-slim AS builder WORKDIR /build COPY ./python-app/requirements.txt /build/ RUN pip install --target=/build/dependencies -r requirements.txt # Final-Stage FROM python:3.12-slim WORKDIR /app COPY --from=builder /build/dependencies /usr/local COPY ./python-app/ /app/ CMD [&quot;python&quot;, &quot;app.py&quot;]   ","version":"Next","tagName":"h3"},{"title":"ErklÃ¤rungâ€‹","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#erklÃ¤rung","content":" Build-Stage: Diese Stage verwendet das python:3.12-slim-Image, um eine Umgebung fÃ¼r den Build-Prozess bereitzustellen. Hier werden die AbhÃ¤ngigkeiten der Anwendung installiert. Durch die Verwendung von --target=/build/dependencies werden die AbhÃ¤ngigkeiten in einem separaten Verzeichnis gespeichert, das spÃ¤ter im finalen Image verwendet werden kann. Final-Stage: Diese Stage startet ebenfalls mit dem python:3.12-slim-Image, um das finale Image so klein wie mÃ¶glich zu halten. Hier werden nur die notwendigen AbhÃ¤ngigkeiten aus der Build-Stage kopiert. AnschlieÃŸend wird der Anwendungscode in das Image kopiert.  ","version":"Next","tagName":"h3"},{"title":"Vorteileâ€‹","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#vorteile","content":" GrÃ¶ÃŸenreduktion: Das finale Image enthÃ¤lt nur die fÃ¼r die AusfÃ¼hrung der Anwendung notwendigen AbhÃ¤ngigkeiten und Artefakte, was zu einem kleineren Image fÃ¼hrt.Sicherheit: Weniger Code und weniger AbhÃ¤ngigkeiten im finalen Image bedeuten eine geringere AngriffsflÃ¤che fÃ¼r SicherheitslÃ¼cken.Effizienz: Multistage Builds ermÃ¶glichen die Wiederverwendung von Zwischenimages, was den Build-Prozess beschleunigen kann, besonders wenn mehrere Builds durchgefÃ¼hrt werden.  ","version":"Next","tagName":"h3"},{"title":"Bau des Imagesâ€‹","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#bau-des-images","content":" Um das Image zu bauen, fÃ¼hre einfach den folgenden Befehl aus:  docker build -t optimierte-python-app .   Durch die Anwendung von Multistage Builds kannst du effizientere, sicherere und kleinere Docker-Images erstellen, die speziell auf die Anforderungen Ihrer Anwendung zugeschnitten sind. ","version":"Next","tagName":"h3"},{"title":"Sicherheitsscans","type":0,"sectionRef":"#","url":"/workshop-container/docs/image_build/08_02_security_scanning","content":"","keywords":"","version":"Next"},{"title":"Trivyâ€‹","type":1,"pageTitle":"Sicherheitsscans","url":"/workshop-container/docs/image_build/08_02_security_scanning#trivy","content":" Installiere Trivy auf deinem Computer, indem du die Anweisungen auf der offiziellen Trivy-Websitefolgst.  Sobald Trivy installiert ist, kannst du ein Bild scannen, indem du den folgenden Befehl eingibst:  trivy image &lt;image-name&gt;   Das Ergebnis sollte Ã¤hnlich wie folgt aussehen:  2024-02-09T15:27:06.080+0100 INFO Need to update DB 2024-02-09T15:27:06.080+0100 INFO DB Repository: ghcr.io/aquasecurity/trivy-db 2024-02-09T15:27:06.080+0100 INFO Downloading DB... 42.79 MiB / 42.79 MiB [----------------------------------------------------------------------------------------] 100.00% 18.23 MiB p/s 2.5s 2024-02-09T15:27:09.741+0100 INFO Vulnerability scanning is enabled 2024-02-09T15:27:09.741+0100 INFO Secret scanning is enabled 2024-02-09T15:27:09.741+0100 INFO If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2024-02-09T15:27:09.741+0100 INFO Please see also https://aquasecurity.github.io/trivy/v0.49/docs/scanner/secret/#recommendation for faster secret detection 2024-02-09T15:27:11.293+0100 INFO Detected OS: alpine 2024-02-09T15:27:11.293+0100 INFO Detecting Alpine vulnerabilities... 2024-02-09T15:27:11.293+0100 INFO Number of language-specific files: 0 2024-02-09T15:27:11.293+0100 WARN This OS version is no longer supported by the distribution: alpine 3.10.9 2024-02-09T15:27:11.293+0100 WARN The vulnerability detection may be insufficient because security updates are not provided alpine:3.10 (alpine 3.10.9) Total: 1 (UNKNOWN: 0, LOW: 0, MEDIUM: 0, HIGH: 0, CRITICAL: 1) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Library â”‚ Vulnerability â”‚ Severity â”‚ Status â”‚ Installed Version â”‚ Fixed Version â”‚ Title â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ apk-tools â”‚ CVE-2021-36159 â”‚ CRITICAL â”‚ fixed â”‚ 2.10.6-r0 â”‚ 2.10.7-r0 â”‚ libfetch: an out of boundary read while libfetch uses strtol â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ to parse... â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ https://avd.aquasec.com/nvd/cve-2021-36159 â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  ","version":"Next","tagName":"h2"},{"title":"EinfÃ¼hrung","type":0,"sectionRef":"#","url":"/workshop-container/docs/intro","content":"EinfÃ¼hrung In diesem Training wirst du die Grundlagen hinter der Containertechnologie Docker lernen. Was sind Container?Docker auf deinem Computer installierenDocker-Container ausfÃ¼hrenLokale Volumes in Container einbindenDocker-Container erstellenWie Netzwerken funktioniert ZusÃ¤tzliche Unterlagen Offizielle Docker Dokumentation","keywords":"","version":"Next"},{"title":"Docker Images","type":0,"sectionRef":"#","url":"/workshop-container/docs/images","content":"Docker Images Du kannst nach auf Docker Hub verfÃ¼gbaren Images suchen, indem du auf den Link &quot;Explore&quot; klickst oder &quot;mariadb&quot; in das Suchfeld eingibst:https://hub.docker.com/search/?q=mariadb&amp;type=image Du erhÃ¤ltst eine Liste mit Ergebnissen und der erste Treffer wird wahrscheinlich das offizielle Image sein: https://hub.docker.com/_/mariadb Diese Seite enthÃ¤lt Anweisungen, wie das Image abgerufen werden kann. Lass uns das machen: docker pull mariadb Hinweis Achte auf Sicherheit! ÃœberprÃ¼fe die Images, bevor du sie ausfÃ¼hrst. Ist es ein offizielles Image?Was ist in dem Image installiert? Lies das Dockerfile, das zum Erstellen des Images verwendet wurdeÃœberprÃ¼fe das Basis-Image Nachdem ein Image heruntergeladen wurde, kannst du dann einen Container mit dem heruntergeladenen Image mit dem Unterbefehl run ausfÃ¼hren. Wenn ein Image nicht heruntergeladen wurde, wenn Docker mit dem Unterbefehl run ausgefÃ¼hrt wird, wird der Docker-Client zuerst das Image herunterladen und dann einen Container damit ausfÃ¼hren: docker run mariadb:latest Hinweis Hier verwenden wir das latest Tag, um die neueste Version des Images zu verwenden. Es ist jedoch eine gute Praxis, ein spezifisches Tag zu verwenden, um sicherzustellen, dass du immer die gleiche Version des Images verwendest. Um die Images zu sehen, die auf deinen Computer heruntergeladen wurden, gib ein: docker images Die Ausgabe sollte Ã¤hnlich wie folgt aussehen: REPOSITORY TAG IMAGE ID CREATED SIZE mariadb latest 58730544b81b 2 weeks ago 397MB hello-world latest 1815c82652c0 2 months ago 1.84kB hello-world linux 1815c82652c0 2 months ago 1.84kB Der Hello-World-Container, den du im vorherigen Lab ausgefÃ¼hrt hast, ist ein Beispiel fÃ¼r einen Container, der lÃ¤uft und beendet wird, nachdem er eine Testnachricht ausgegeben hat. Container kÃ¶nnen jedoch viel nÃ¼tzlicher sein und sie kÃ¶nnen interaktiv sein. SchlieÃŸlich sind sie Ã¤hnlich wie virtuelle Maschinen, nur ressourcenfreundlicher. Als Beispiel fÃ¼hren wir einen Container mit dem neuesten Image von MariaDB aus. Die Kombination der Schalter -i und -t gibt dir interaktiven Shell-Zugriff auf den Container: docker run -it mariadb:latest Hinweis fÃ¼r Windows Wenn du git-bash, cmd oder powershell auf einem Windows-System verwendest, achte auf den Fehler: the input device is not a TTY. If you are using mintty, try prefixing the command with 'winpty' Setze winpty am Anfang jedes Befehls, der die -it Parameter verwendet. Zum Beispiel: winpty docker run -it mariadb:latest Ein Fehler ist aufgetaucht! 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:11.2.2+maria~ubu2204 started. 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql' 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:11.2.2+maria~ubu2204 started. 2024-02-09 11:44:31+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ROOT_PASSWORD_HASH, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD ğŸ¤” Warum ist dieser Fehler aufgetreten? Ist es ein Bug im Image? Alles ist in Ordnung, um dieses Image auszufÃ¼hren, ist eine gewisse Konfiguration erforderlich. Lies den folgenden Auszug sorgfÃ¤ltig durch. error: database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD ğŸ¤” Was ist ein Image? Denke an ein Image wie an einen Bauplan, der verwendet wird, um Container zu erstellen. Ein Image ist eine Sammlung von Dateien + einigen Metadaten (oder in technischen Begriffen: diese Dateien bilden das Root-Dateisystem eines Containers)Images bestehen aus Schichten, die konzeptionell Ã¼bereinander gestapelt sindJede Schicht kann Dateien hinzufÃ¼gen, verÃ¤ndern oder entfernenImages kÃ¶nnen Schichten teilen, um die Nutzung von Festplattenspeicher, Ãœbertragungszeiten und Speichernutzung zu optimierenDu baust diese Images mit Hilfe von Dockerfiles (in spÃ¤teren Labs)Images sind unverÃ¤nderlich, du kannst sie nach der Erstellung nicht Ã¤ndern ğŸ¤” Was ist der Unterschied zwischen einem Container und einem Image? Wenn du ein Image ausfÃ¼hrst, wird es zu einem Container. Ein Image ist ein schreibgeschÃ¼tztes DateisystemEin Container ist ein eingekapselter Satz von Prozessen, der in einer schreibbaren Kopie dieses Dateisystems lÃ¤uftdocker run startet einen Container aus einem gegebenen Image","keywords":"","version":"Next"},{"title":"8. Wie funktioniert das Image-Building?","type":0,"sectionRef":"#","url":"/workshop-container/docs/image_build/","content":"","keywords":"","version":"Next"},{"title":"Dockerfileâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#dockerfile","content":" Docker kann Container-Images erstellen, indem es Anweisungen aus einem sogenannten Dockerfile oder allgemeiner einem Containerfile liest. Die grundlegende Dokumentation dazu, wie Dockerfiles funktionieren, findest du unter https://docs.docker.com/engine/reference/builder/.  ","version":"Next","tagName":"h2"},{"title":"Schreibe dein erstes Dockerfileâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#schreibe-dein-erstes-dockerfile","content":" Bevor wir unser Python-Image erweitern, werden wir uns generell anschauen, wie man ein Container-Image erstellt. DafÃ¼r erstelle ein neues Verzeichnis mit einem leeren Dockerfile darin.  mkdir myfirstimage cd myfirstimage   FÃ¼ge den folgenden Inhalt zum Dockerfile mit deinem bevorzugten Editor hinzu:  Dockerfile FROM ubuntu RUN apt-get update &amp;&amp; \\ apt-get install -y figlet &amp;&amp; \\ apt-get clean   FROM gibt das Basis-Image fÃ¼r unseren Build anJede RUN-Zeile wird von Docker wÃ¤hrend des Builds ausgefÃ¼hrtUnsere RUN-Befehle mÃ¼ssen nicht-interaktiv sein (keine Eingabe kann wÃ¤hrend des Builds an Docker bereitgestellt werden)ÃœberprÃ¼fe https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/ fÃ¼r weitere Best Practices, wie man Dockerfiles schreibt.  ","version":"Next","tagName":"h2"},{"title":"Baue das Imageâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#baue-das-image","content":" FÃ¼hre einfach aus:  docker build -t myfirstimage .   -t gibt das Tag an, das auf das Image angewendet werden soll. gibt den Ort des Build-Kontexts an (Ã¼ber den wir spÃ¤ter noch mehr sprechen werden, aber im Grunde ist es das Verzeichnis, in dem unser Dockerfile liegt)  Hinweis Verwende den zusÃ¤tzlichen Parameter --build-arg, wenn du hinter einem Firmenproxy bist: docker build -t myfirstimage --build-arg http_proxy=http://&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt; .   Bitte beachte, dass das Tag in den meisten Docker-Befehlen und Anweisungen weggelassen werden kann. In diesem Fall ist das Standard-Tag latest. Abgesehen davon, dass es das Standard-Tag ist, hat latest nichts Besonderes. Trotz seines Namens identifiziert es nicht notwendigerweise die neueste Version eines Images. Je nach Build-System kann es auf das zuletzt gepushte Image, auf das zuletzt aus einem Zweig gebaute Image oder auf ein altes Image zeigen. Es kann sogar Ã¼berhaupt nicht existieren. Aus diesem Grund solltest du niemals das Tag latest in Produktion verwenden, verwende immer eine spezifische Image-Version. Siehe auch: https://medium.com/@mccode/the-misunderstood-docker-tag-latest-af3babfd6375  ","version":"Next","tagName":"h2"},{"title":"Was passiert beim Build des Imagesâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#was-passiert-beim-build-des-images","content":" Die Ausgabe des Docker-Builds sieht folgendermaÃŸen aus:  Sending build context to Docker daemon 2.048kB Step 1/2 : FROM ubuntu ---&gt; ea4c82dcd15a Step 2/2 : RUN apt-get update &amp;&amp; apt-get install -y figlet &amp;&amp; apt-get clean ---&gt; b3c08112fd1c Successfully built b3c08112fd1c Successfully tagged myfirstimage:latest   ","version":"Next","tagName":"h3"},{"title":"Das Senden des Build-Kontexts an Dockerâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#das-senden-des-build-kontexts-an-docker","content":" Sending build context to Docker daemon 84.48 kB ...   Der Build-Kontext ist das .-Verzeichnis, das an docker build Ã¼bergeben wurdeEs wird (als Archiv) vom Docker-Client an den Docker-Daemon gesendetDies ermÃ¶glicht es dir, eine Remote-Maschine zum Bauen unter Verwendung lokaler Dateien zu verwendenSei vorsichtig (oder geduldig), wenn dieses Verzeichnis groÃŸ ist und deine Verbindung langsam ist  ","version":"Next","tagName":"h3"},{"title":"Untersuchung der AusfÃ¼hrungsschritteâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#untersuchung-der-ausfÃ¼hrungsschritte","content":" ... Step 1/2 : FROM ubuntu ---&gt; ea4c82dcd15a Step 2/2 : RUN apt-get update &amp;&amp; apt-get install -y figlet &amp;&amp; apt-get clean ---&gt; b3c08112fd1c Successfully built b3c08112fd1c Successfully tagged myfirstimage:latest   Ein Container (ea4c82dcd15a) wird aus dem Basis-Image erstellt Das Basis-Image wird heruntergeladen, falls es vorher nicht heruntergeladen wurde Der RUN-Befehl wird in diesem Container ausgefÃ¼hrtDer Container wird zu einem Image (b3c08112fd1c) committedDer Build-Container (ea4c82dcd15a) wird entferntDas Ergebnis dieses Schritts wird die Basis fÃ¼r den nÃ¤chsten sein...  ","version":"Next","tagName":"h3"},{"title":"Das Caching-Systemâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#das-caching-system","content":" Wenn du denselben Build erneut ausfÃ¼hrst, wird er sofort abgeschlossen. Warum?  Nach jedem Build-Schritt macht Docker ein SnapshotBevor ein Schritt ausgefÃ¼hrt wird, Ã¼berprÃ¼ft Docker, ob es dieselbe Sequenz bereits gebaut hatDocker verwendet die exakten Strings, die in deinem Dockerfile definiert sind: RUN apt-get install figlet cowsay unterscheidet sich vonRUN apt-get install cowsay figletRUN apt-get update wird nicht erneut ausgefÃ¼hrt, wenn die Spiegel aktualisiert werden Alle Schritte nach einem geÃ¤nderten Schritt werden erneut ausgefÃ¼hrt, da das Dateisystem, auf dem sie basieren, geÃ¤ndert worden sein kÃ¶nnte  Du kannst einen Neubau mit docker build --no-cache ... erzwingen.  Wenn du nur einen teilweisen Neubau auslÃ¶sen mÃ¶chtest, z.B. apt-get update ausfÃ¼hren, um die neuesten Updates zu installieren, kannst du folgendes Muster verwenden:  ENV REFRESHED_AT 2020-03-13 RUN apt-get update   Wenn du den Wert von REFRESHED_AT aktualisierst, wird der Docker-Build-Cache dieses und aller folgenden Schritte invalidiert, wodurch die neuesten Updates installiert werden.  ","version":"Next","tagName":"h3"},{"title":"FÃ¼hre es ausâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#fÃ¼hre-es-aus","content":" FÃ¼hre jetzt dein Image aus  docker run -ti myfirstimage   Du findest dich in einer Bash-Shell im Container wieder, fÃ¼hre aus  figlet hello   und du wirst folgende Ausgabe sehen:  root@00f0766080ed:/# figlet hello _ _ _ | |__ ___| | | ___ | '_ \\ / _ \\ | |/ _ \\ | | | | __/ | | (_) | |_| |_|\\___|_|_|\\___/ root@00f0766080ed:/#   Verlasse den Container durch AusfÃ¼hren von:  exit   ","version":"Next","tagName":"h3"},{"title":"Die CMD-Anweisung im Dockerfileâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#die-cmd-anweisung-im-dockerfile","content":" Mit der CMD-Anweisung im Dockerfile kÃ¶nnen wir den Befehl definieren, der ausgefÃ¼hrt wird, wenn ein Container gestartet wird.  ğŸ¤” Kannst du herausfinden, welche CMD-Anweisung das Ubuntu-Image hat? Du hast dich in einer Shell befunden, daher muss die Anweisung entweder /usr/bin/bash oder /usr/bin/sh sein.  Modifiziere das zuvor erstellte Dockerfile wie folgt:  FROM ubuntu RUN apt-get update &amp;&amp; \\ apt-get install -y figlet &amp;&amp; \\ apt-get clean CMD [&quot;figlet&quot;, &quot;hello&quot;]   Baue das Image mit:  docker build -t myfirstimagecmd .   Hinweis Verwende erneut den zusÃ¤tzlichen Parameter --build-arg, wenn du hinter einem Firmenproxy bist: docker build -t myfirstimagecmd --build-arg http_proxy=http://&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt; .   Und fÃ¼hre es aus:  docker run -ti myfirstimagecmd   Es fÃ¼hrt direkt den definierten Befehl aus und gibt aus   _ _ _ | |__ ___| | | ___ | '_ \\ / _ \\ | |/ _ \\ | | | | __/ | | (_) | |_| |_|\\___|_|_|\\___/   Weitere Informationen findest du unter https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact.  ","version":"Next","tagName":"h2"},{"title":"Frontend-App-Image bauenâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#frontend-app-image-bauen","content":" Nachdem wir die Grundlagen des Image-Buildings verstanden haben, mÃ¶chten wir nun den Quellcode unserer Frontend-App in ein bereits erstelltes Container-Image einbinden. Dazu werden wir ein Dockerfile erstellen.  Das Basis-Image ist unser php:8-apache-Image, das wir zuvor verwendet haben. Der ADD-Befehl ermÃ¶glicht es uns, Dateien aus unserem aktuellen Verzeichnis zum Docker-Image hinzuzufÃ¼gen. Wir verwenden diesen Befehl, um den Anwendungsquellcode in das Image einzufÃ¼gen.  Hinweis Verwende .dockerignore, um Dateien vom HinzufÃ¼gen zum Container durch den Docker-Kontext auszuschlieÃŸen. Es funktioniert genauso wie .gitignore: https://docs.docker.com/engine/reference/builder/#dockerignore-file  Im Verzeichnis, das das Unterverzeichnis python-app enthÃ¤lt, erstelle ein Dockerfile mit dem folgenden Inhalt:  FROM python:3.12-slim # Kopiert den Python-Quellcode an den korrekten Ort ADD ./python-app/ /app/ # Setzt das Arbeitsverzeichnis WORKDIR /app # Installiert AbhÃ¤ngigkeiten RUN pip install -r requirements.txt # Startet die Anwendung CMD [&quot;python&quot;, &quot;app.py&quot;]   ","version":"Next","tagName":"h2"},{"title":"Baue das python-app-Imageâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#baue-das-python-app-image","content":" Hinweis Stoppe und lÃ¶sche den laufenden python-app-Container zuerst. Lasse den Datenbank-Container laufen.  Baue nun das Image:  docker build -t python-app .   ","version":"Next","tagName":"h3"},{"title":"FÃ¼hre den python-app-Container ausâ€‹","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#fÃ¼hre-den-python-app-container-aus","content":" Nach einem erfolgreichen Build fÃ¼hre ihn aus:  docker run -d --network container-basics-training --name python-app -p 5000:5000 python-app   Ã–ffne nun einen Browser und navigiere zu http://localhost:5000 (oder in der Webshell verwende curl http://localhost:5000). Du solltest eine Antwort erhalten, die besagt, dass die Verbindung erfolgreich hergestellt wurde. ","version":"Next","tagName":"h3"},{"title":"6. Volumes","type":0,"sectionRef":"#","url":"/workshop-container/docs/volumes","content":"","keywords":"","version":"Next"},{"title":"Ein Volume in einem Container einbindenâ€‹","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#ein-volume-in-einem-container-einbinden","content":" Der MariaDB-Container ist ein gutes Beispiel dafÃ¼r, warum es gut ist, ein externes Volume zu haben. Es gibt mehrere MÃ¶glichkeiten, wie man mit Volumes in Docker arbeiten kann, in diesem Fall werden wir ein von Docker verwaltetes Volume erstellen, um die persistenten Daten unserer MariaDB zu speichern. Das Volume wird von Docker selbst verwaltet.  Erstelle das von Docker verwaltete Volume mit:  docker volume create volume-mariadb   Nun benutze das erstellte Volume und hÃ¤nge es an die MariaDB-Datenbank an.  Mit dem Parameter -v das Volume an einen Pfad im Container anhÃ¤ngen:  docker run --name mariadb-container-with-external-volume -v volume-mariadb:/var/lib/mysql -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb   Siehe Dokumentation zu Docker-Volumes fÃ¼r mehr Informationen.  Okay, nun erstelle einen neuen Benutzer im MariaDB-Container:  docker exec -it mariadb-container-with-external-volume mariadb -uroot -pmy-secret-pw   Im mariadb-Client fÃ¼hre einige SQL-Befehle aus:  use mysql CREATE USER 'peter'@'%' IDENTIFIED BY 'venkman'; GRANT SELECT ON * . * TO 'peter'@'%';   Sobald alle Schritte abgeschlossen sind, beende die MySQL-Sitzung und verlasse den Container:  exit;   Um zu testen, ob Peter korrekt erstellt wurde, einfach mit seinen Anmeldedaten einloggen.  Nun stoppe und entferne den mariadb-container-with-external-volume Container.  docker stop mariadb-container-with-external-volume docker rm mariadb-container-with-external-volume   Als NÃ¤chstes Ã¼berprÃ¼fe, ob die Daten noch verfÃ¼gbar sind. Erstelle einen neuen MariaDB-Container mit dem vorherigen Volume:  docker run --name mariadb-container-with-existing-external-volume \\ -v volume-mariadb:/var/lib/mysql \\ -e MARIADB_ROOT_PASSWORD=my-secret-pw \\ -d mariadb   Der Moment der Wahrheit... Verbinde dich mit dem Datenbankserver mit Peters Anmeldedaten:  docker exec -it mariadb-container-with-existing-external-volume mariadb -upeter -pvenkman   Du solltest nun als peter mit deiner Datenbankinstanz verbunden sein. Du kannst dies testen, indem du die Benutzer mit dem SQL-Client auflistest:  SELECT User FROM mysql.user;   +-----------------+ | USER() | +-----------------+ | peter@localhost | +-----------------+ 1 Zeile in Satz (0.00 Sek.)   Jetzt verlasse den MySQL-Client  exit;   ","version":"Next","tagName":"h2"},{"title":"ZusÃ¤tzliche Infos zur Arbeit mit Docker-Volumesâ€‹","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#zusÃ¤tzliche-infos-zur-arbeit-mit-docker-volumes","content":" Docker-Volumes kÃ¶nnen verwendet werden fÃ¼r:  Entkoppeln der gespeicherten Daten vom Container, der die Daten erstellt hatUmgehen des Copy-on-Write-Systems, um native Festplatten-I/O-Leistung zu erzielenUmgehen von Copy-on-Write, um einige Dateien aus dem Docker-Commit auszuschliessenTeilen eines Verzeichnisses zwischen mehreren ContainernTeilen eines Verzeichnisses zwischen dem Host und einem ContainerTeilen einer einzelnen Datei zwischen dem Host und einem Container Eine Alternative zur Arbeit mit Volumes wÃ¤re das Einbinden lokaler Verzeichnisse (Host-Ordner) Ã¼ber einen Pfad in deinen Container. Dies werden wir in Kapitel 08 verwenden.  ","version":"Next","tagName":"h2"},{"title":"Docker-Speichertreiberâ€‹","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#docker-speichertreiber","content":" Wenn du viele Docker-Container auf einer Maschine betreibst, benÃ¶tigst du normalerweise viel Speicher. Docker-Volumes und Container-Speicher werden auf einem Dateisystem bereitgestellt. Der folgende Link bietet zusÃ¤tzliche Informationen darÃ¼ber, wie du das richtige Speichersetup auswÃ¤hlst:  https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/managing_containers/managing_storage_with_docker_formatted_containers  Derzeit ist overlay2 der empfohlene Speichertreiber. ","version":"Next","tagName":"h3"},{"title":"Umgebungsvariablen (Environment Variables)","type":0,"sectionRef":"#","url":"/workshop-container/docs/umgebungs_variablen","content":"","keywords":"","version":"Next"},{"title":"Detached Containersâ€‹","type":1,"pageTitle":"Umgebungsvariablen (Environment Variables)","url":"/workshop-container/docs/umgebungs_variablen#detached-containers","content":" Es gibt eine MÃ¶glichkeit, Container im Hintergrund laufen zu lassen, ohne dass sie die Shell blockieren. DafÃ¼r musst du den Parameter -d verwenden, z.B.:  docker run -d -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb   Wenn du den Befehl ausfÃ¼hrst, wirst du eine Ausgabe wie diese sehen:  1a84e2e51ff2   Das ist die ID des Containers, die du verwenden kannst, um auf den Container zuzugreifen oder ihn zu stoppen. Wenn du nun alle laufenden Container sehen mÃ¶chtest, verwende den folgenden Befehl:  docker ps   Die Ausgabe sollte Ã¤hnlich wie folgt aussehen:  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1a84e2e51ff2 mariadb &quot;docker-entrypoint.sâ€¦&quot; 3 minutes ago Up 3 minutes 3306/tcp amazing_mendeleev  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}