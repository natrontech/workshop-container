{"searchDocs":[{"title":"Container l√∂schen","type":0,"sectionRef":"#","url":"/workshop-container/docs/container_loeschen","content":"Container l√∂schen Es gibt zwei M√∂glichkeiten einen Container zu l√∂schen. Wir starten mit dem einfachsten Weg, um einen Container zu l√∂schen. Zuerst musst du den Namen oder die ID des Containers herausfinden, den du l√∂schen m√∂chtest. docker ps Die Ausgabe sollte √§hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 9 minutes ago Up 9 minutes 3306/tcp focused_noether In diesem Beispiel ist der Name des Containers focused_noether. Um den Container zu l√∂schen, gib ein: docker stop focused_noether Jetzt kannst du √ºberpr√ºfen, ob der Container gestoppt ist, indem du den folgenden Befehl eingibst: docker ps -a Die Ausgabe sollte √§hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 9 minutes ago Exited (0) 2 minutes ago focused_noether Wir haben somit den container &quot;gracefully&quot; gestoppt, aber es gibt auch die M√∂glichkeit, einen Container &quot;forcefully&quot; zu stoppen. Dazu gibst du den folgenden Befehl ein: docker kill focused_noether Wenn der Container gestoppt ist, kannst du ihn l√∂schen, indem du den folgenden Befehl eingibst: docker rm focused_noether Hinweis Es ist eine gute Praxis, Container zu l√∂schen, die nicht mehr ben√∂tigt werden, um Speicherplatz freizugeben. ü§î Wo kommen diese komischen Namen der Container her? Docker generiert automatisch Namen f√ºr Container, wenn du keinen Namen angibst. Das ist n√ºtzlich, wenn du viele Container auf deinem Computer ausf√ºhrst und nicht jedes Mal einen Namen ausdenken m√∂chtest. Wie du einen Container mit einem Namen erstellst, erf√§hrst du im n√§chsten Lab.","keywords":"","version":"Next"},{"title":"Benennen von Containern","type":0,"sectionRef":"#","url":"/workshop-container/docs/container_name","content":"Benennen von Containern Im Gegensatz zur CONTAINER ID ist der NAME etwas, das wir manipulieren k√∂nnen. Der Name ist praktisch, nicht nur zum Starten/Verbinden/Stoppen/Zerst√∂ren eines Containers, sondern auch f√ºr das Networking (was wir in einem sp√§teren Lab sehen werden). Um einen Namen zu setzen, f√ºge den Parameter --name zum run Befehl von Docker hinzu: docker run --name mariadb-container -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb Wie immer, um zu √ºberpr√ºfen, ob dies wirklich funktioniert hat, schau dir die Container-Liste an: docker ps Die Ausgabe sollte √§hnlich wie folgt aussehen: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26f164a65285 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 9 minutes ago Up 9 minutes 3306/tcp mariadb-container Anstatt wie im letzten Lab auf die Datenbank von innerhalb des Containers zuzugreifen, greifen wir von aussen mit einem lokalen mysqlclient darauf zu. Das ist ein bisschen knifflig. Zuerst musst du die IP-Adresse deines Docker-Containers herausfinden. Daf√ºr verwendest du diesen Befehl: docker inspect mariadb-container -f '{{ range.NetworkSettings.Networks }}{{ .IPAddress }}{{ end }}' docker inspect &lt;container&gt; zeigt dir Details √ºber einen laufenden Container im JSON-Format an (f√ºhre es selbst aus und schau es dir an). Wir haben das JSON gefiltert, um nur die IP-Adresse des Containers zu erhalten. Wir h√§tten auch den Output mit grep filtern k√∂nnen: docker inspect mariadb-container | grep IPAddress, aber unsere L√∂sung ist eleganter üòä. Sobald du die IP hast (in deinem Beispiel 172.17.0.2), verbinde dich damit: mysql -h172.17.0.2 -uroot -pmy-secret-pw Wenn alles funktioniert, beende den MySQL-Client mit: exit; Hinweis f√ºr Windows Der MySQL-Client muss auf deinem Computer installiert sein. Unter Windows kannst du das Binary aus dem ZIP-Archiv verwenden: https://dev.mysql.com/downloads/mysql/. Auch unter Windows musst du Port-Weiterleitung nutzen, um auf die Datenbank zuzugreifen: docker run --name mariadb-container -p 3306:3306 -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb Jetzt solltest du in der Lage sein, auf die Datenbank zuzugreifen mit: winpty mysql.exe -hlocalhost -uroot -pmy-secret-pw mariadb ü§î Kannst du dir einen anderen Weg vorstellen, auf die Datenbank zuzugreifen? Anstatt den Container mit bash zu betreten, k√∂nnten wir auch direkt MySQL innerhalb des Containers ausf√ºhren: docker exec -it mariadb-container mysql -uroot -pmy-secret-pw ","keywords":"","version":"Next"},{"title":"9. MariaDB-Container verbinden","type":0,"sectionRef":"#","url":"/workshop-container/docs/connect_mariadb","content":"","keywords":"","version":"Next"},{"title":"Vorbereitung der MariaDB-Instanz‚Äã","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#vorbereitung-der-mariadb-instanz","content":" Bevor wir unsere Flask-Anwendung erweitern, m√ºssen wir sicherstellen, dass unser MariaDB-Container l√§uft und mit Daten gef√ºllt ist, die wir abfragen k√∂nnen.  ","version":"Next","tagName":"h2"},{"title":"√úberpr√ºfung, ob der MariaDB-Container l√§uft‚Äã","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#√ºberpr√ºfung-ob-der-mariadb-container-l√§uft","content":" L√∂sche den alten MariaDB-Container, falls er noch l√§uft:  docker ps docker stop &lt;container-id&gt; docker rm &lt;container-id&gt;   Starte ihn erneut:  docker run --name mariadb-container \\ -v volume-mariadb:/var/lib/mysql \\ -e MARIADB_ROOT_PASSWORD=my-secret-pw \\ -d mariadb   ","version":"Next","tagName":"h3"},{"title":"Bef√ºllen der MariaDB mit Mock-Daten‚Äã","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#bef√ºllen-der-mariadb-mit-mock-daten","content":" Verbinde dich mit der MariaDB-Instanz:  docker exec -it mariadb-container mariadb -uroot -pmy-secret-pw   Erstelle eine einfache Tabelle und f√ºge einige Mock-Daten ein:  CREATE DATABASE flaskapp; USE flaskapp; CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, email VARCHAR(255) NOT NULL ); INSERT INTO users (name, email) VALUES ('John Doe', 'john.doe@example.com'), ('Jane Doe', 'jane.doe@example.com');   Verlasse die MariaDB-Shell mit:  exit;   ","version":"Next","tagName":"h3"},{"title":"Erweiterung der Flask-Anwendung‚Äã","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#erweiterung-der-flask-anwendung","content":" Um die Flask-Anwendung zu erweitern, damit sie auf die MariaDB-Instanz zugreifen kann, ben√∂tigen wir einen MySQL-Treiber f√ºr Python. Wir werden PyMySQL verwenden.  ","version":"Next","tagName":"h2"},{"title":"Aktualisierung der requirements.txt‚Äã","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#aktualisierung-der-requirementstxt","content":" F√ºge PyMySQL zur requirements.txt hinzu:  requirements.txt Flask==3.0.2 PyMySQL==1.1.0   ","version":"Next","tagName":"h3"},{"title":"Aktualisierung der Flask-Anwendung‚Äã","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#aktualisierung-der-flask-anwendung","content":" Aktualisiere die app.py, um eine Verbindung zur MariaDB herzustellen und Daten aus der users-Tabelle zu lesen:  app.py from flask import Flask, jsonify import pymysql.cursors app = Flask(__name__) def get_db_connection(): connection = pymysql.connect(host='mariadb-container', user='root', password='my-secret-pw', database='flaskapp', cursorclass=pymysql.cursors.DictCursor) return connection @app.route('/') def users(): connection = get_db_connection() with connection.cursor() as cursor: cursor.execute(&quot;SELECT * FROM users&quot;) users = cursor.fetchall() connection.close() return jsonify(users) if __name__ == '__main__': app.run(debug=True, host='0.0.0.0', port=5000)   ","version":"Next","tagName":"h3"},{"title":"Neubau und Neustart des Flask-Containers‚Äã","type":1,"pageTitle":"9. MariaDB-Container verbinden","url":"/workshop-container/docs/connect_mariadb#neubau-und-neustart-des-flask-containers","content":" Baue das Docker-Image f√ºr die Anwendung erneut, um die √Ñnderungen zu √ºbernehmen:  docker build -t python-flask-app .   Stoppe und entferne den alten Flask-Container, falls er noch l√§uft:  docker stop python-webapp docker rm python-webapp   Starte den Flask-Container erneut:  docker run -d -p 5000:5000 --name python-webapp --link mariadb-container:mariadb-container python-flask-app   Nun kannst du auf http://localhost:5000 zugreifen, um die Daten aus der MariaDB-Instanz in deiner Flask-Anwendung angezeigt zu bekommen. ","version":"Next","tagName":"h3"},{"title":"Erste Schritte","type":0,"sectionRef":"#","url":"/workshop-container/docs/erste_schritte","content":"","keywords":"","version":"Next"},{"title":"Die Kommandozeile‚Äã","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#die-kommandozeile","content":" Mit Docker installiert und funktionsf√§hig, ist jetzt der richtige Zeitpunkt, dich mit der Befehlszeilenanwendung vertraut zu machen. Die Verwendung von Docker besteht darin, mindestens einen Befehl zu verwenden. docker --help zeigt die verf√ºgbaren Optionen.  docker --help   Usage: docker COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default &quot;/home/user/.docker&quot;) -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default &quot;/home/user/.docker/ca.pem&quot;) --tlscert string Path to TLS certificate file (default &quot;/home/user/.docker/cert.pem&quot;) --tlskey string Path to TLS key file (default &quot;/home/user/.docker/key.pem&quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quit Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes Run 'docker COMMAND --help' for more information on a command.   Um die f√ºr einen spezifischen Befehl verf√ºgbaren Schalter zu sehen, tippe:  docker &lt;command&gt; --help   Um systemweite Informationen √ºber Docker zu sehen, benutze:  docker info   ","version":"Next","tagName":"h2"},{"title":"Hello World (mit Docker)‚Äã","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#hello-world-mit-docker","content":" Docker-Container werden aus Docker-Images ausgef√ºhrt. Standardm√§√üig ziehen sie diese Images von Docker Hub, einer Docker-Registry, die von Docker Inc, dem Unternehmen hinter dem Docker-Projekt, verwaltet wird. Jeder kann seine Docker-Images auf Docker Hub erstellen und hosten, daher findest du f√ºr viele Anwendungen und Linux-Distributionen Docker-Images, die auf Docker Hub gehostet werden.  Um zu √ºberpr√ºfen, ob du auf Docker Hub zugreifen und Images herunterladen kannst, tippe:  docker run hello-world   Die Ausgabe, die Folgendes beinhalten sollte, deutet darauf hin, dass Docker korrekt zu funktionieren scheint:  Hello from Docker. This message shows that your installation appears to be working correctly. ...   ","version":"Next","tagName":"h2"},{"title":"Dein erster Container üéâ‚Äã","type":1,"pageTitle":"Erste Schritte","url":"/workshop-container/docs/erste_schritte#dein-erster-container-","content":" Mit diesem Befehl haben wir gerade unseren ersten Container auf unserem Computer ausgef√ºhrt. Er f√ºhrte einen einfachen Prozess aus, der eine Nachricht auf der Standardausgabe ausgab, der Container selbst ist jedoch nicht sehr n√ºtzlich.  Docker Dokumentation  Besuche https://docs.docker.com und mache dich mit den Dokumentationen sowie den Referenzen vertraut. In diesem Training verwenden wir Docker CE, daher k√∂nnte es auch sinnvoll sein, diesen Abschnitt in der Dokumentation zu √ºberpr√ºfen.  Frage: Muss ich den Namen des Docker Images auswendig kennen? Nein! Es gibt Unmengen von Images, die von Unternehmen, Open-Source-Projekten und Einzelpersonen bereitgestellt werden. Du kannst diese Images in verschiedenen Registries suchen, einige der bekannteren sind Docker Hub und Github Container Registry. Sieh dir das n√§chste Lab f√ºr weitere Details an. ","version":"Next","tagName":"h2"},{"title":"7. Eigener Container bereitstellen","type":0,"sectionRef":"#","url":"/workshop-container/docs/frontend_container","content":"","keywords":"","version":"Next"},{"title":"Eine Python-Webanwendung als Frontend-Container bereitstellen‚Äã","type":1,"pageTitle":"7. Eigener Container bereitstellen","url":"/workshop-container/docs/frontend_container#eine-python-webanwendung-als-frontend-container-bereitstellen","content":" Zuerst m√ºssen wir das passende Docker-Image finden --&gt; Wo? Genau... auf Docker Hub.  Verwende das Image python:3.12-slim als Basis, um eine einfache Python-Webanwendung mit Flask zu deployen.  docker pull python:3.12-slim   Sobald das Image heruntergeladen wurde, kannst du deine lokalen docker images √ºberpr√ºfen:  docker images   Dies zeigt die Images im lokalen Register mit ihrem Namen und Tags an.  Als N√§chstes bereiten wir einen einfachen Flask-Webserver vor. Erstelle daf√ºr eine Datei namens app.py mit folgendem Inhalt:  app.py from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World von Flask!' if __name__ == '__main__': app.run(debug=True, host='0.0.0.0')   Zus√§tzlich ben√∂tigst du eine requirements.txt-Datei f√ºr Flask:  requirements.txt Flask==3.0.2   Erstelle ein Dockerfile, um die App und ihre Abh√§ngigkeiten in ein Image zu packen:  Dockerfile FROM python:3.12-slim WORKDIR /app COPY requirements.txt requirements.txt RUN pip install -r requirements.txt COPY . . CMD [&quot;python&quot;, &quot;app.py&quot;]   Baue das Docker-Image f√ºr die Anwendung:  docker build -t python-flask-app .   Nun deploye den neuen Container mit dem soeben erstellten Image:  docker run -d -p 5000:5000 --name python-webapp python-flask-app   docker ps zeigt alle laufenden Container. √úberpr√ºfe, ob python-webapp l√§uft:  docker ps   Nun kannst du versuchen, dich mit dem Server √ºber die zugewiesene Docker-IP-Adresse zu verbinden oder, falls du Portweiterleitung verwendet hast, direkt √ºber http://localhost:5000.  Wenn du innerhalb einer Umgebung ohne direkten Browserzugriff arbeitest (z.B. Webshell), kannst du curl http://localhost:5000 verwenden, um die Seite in deinem Terminal zu √∂ffnen.  Hinweis f√ºr Windows und macOS Wenn du unter Windows oder macOS arbeitest und den Container bereits gestartet hast, solltest du in der Lage sein, direkt √ºber http://localhost:5000 auf die Webanwendung zuzugreifen, dank der Portweiterleitung, die im docker run-Befehl definiert wurde.  Damit hast du erfolgreich einen Frontend-Container mit einer Python-Webanwendung deployt, die auf Flask basiert.  Im n√§chsten Lab lernst du, wie genau ein Container Image erstellt wird. ","version":"Next","tagName":"h2"},{"title":"Debugging von Containern","type":0,"sectionRef":"#","url":"/workshop-container/docs/debugging","content":"","keywords":"","version":"Next"},{"title":"Docker-Systeminformationen‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#docker-systeminformationen","content":" Um einen umfassenden √úberblick √ºber den Zustand und die Konfiguration deiner Docker-Installation zu erhalten, kannst du den Befehl docker info verwenden. Dies liefert detaillierte Informationen √ºber die Anzahl der Container, Images, die Serverversion, verwendete Treiber und vieles mehr. Ein Beispieloutput k√∂nnte so aussehen:  docker info   Containers: 42 Running: 0 Paused: 0 Stopped: 42 Images: 75 Server Version: 18.06.1-ce ...   ","version":"Next","tagName":"h2"},{"title":"Container auflisten‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-auflisten","content":" Um den aktuellen Status deiner Container zu √ºberpr√ºfen, kannst du verschiedene Varianten des docker ps Befehls verwenden:  Laufende Container anzeigen: Der Standardbefehl docker ps zeigt alle aktuell laufenden Container an. Alle Container anzeigen: Mit docker ps -a erh√§ltst du eine Liste aller Container, einschliesslich der gestoppten. Den letzten Container anzeigen: docker ps -l zeigt den zuletzt gestarteten Container an. Nur IDs laufender Container anzeigen: Mit docker ps -q kannst du schnell die IDs aller laufenden Container abrufen. Containergr√∂ssen anzeigen: docker ps -s gibt zus√§tzlich die Gr√∂sse der Container aus.  Hinweis docker container ls ist ein √§quivalenter Befehl zu docker ps und kann ebenfalls verwendet werden, um Container zu listen.  ","version":"Next","tagName":"h2"},{"title":"Ressourcennutzung √ºberwachen‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#ressourcennutzung-√ºberwachen","content":" Speicher- und CPU-Verbrauch: Der Befehl docker stats liefert Echtzeitdaten zum Ressourcenverbrauch aller laufenden Container. Speicherverteilung anzeigen: docker system df zeigt die Speichernutzung durch Container, Images und Volumes an.  ","version":"Next","tagName":"h2"},{"title":"Container-Logs‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-logs","content":" Um Einblicke in die Aktivit√§ten eines Containers zu erhalten, kannst du die Logs mit docker logs &lt;container&gt; abrufen. Dies ist besonders n√ºtzlich, um Fehlermeldungen oder andere Ausgaben der Anwendung zu √ºberpr√ºfen.  ","version":"Next","tagName":"h2"},{"title":"Container inspizieren‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-inspizieren","content":" F√ºr eine detaillierte Ansicht der Konfiguration und des Zustands eines Containers nutze docker inspect &lt;container&gt;. Dieser Befehl liefert JSON-formatierte Daten zu Netzwerkeinstellungen, Volumes und vielem mehr.  ","version":"Next","tagName":"h2"},{"title":"In Container eintreten‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#in-container-eintreten","content":" Um Befehle innerhalb eines laufenden Containers auszuf√ºhren oder eine interaktive Shell zu starten, verwende docker exec -it &lt;container&gt; /bin/bash (oder /bin/sh f√ºr leichtgewichtigere Images).  ","version":"Next","tagName":"h2"},{"title":"Prozesse im Container anzeigen‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#prozesse-im-container-anzeigen","content":" docker top &lt;container&gt; zeigt die aktuell im Container laufenden Prozesse an, √§hnlich dem top Befehl in Unix-basierten Systemen.  ","version":"Next","tagName":"h2"},{"title":"Datei√§nderungen verfolgen‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#datei√§nderungen-verfolgen","content":" Mit docker diff &lt;container&gt; kannst du √Ñnderungen an den Dateien im Container seit dessen Start identifizieren. Dies umfasst hinzugef√ºgte, ge√§nderte und gel√∂schte Dateien.  ","version":"Next","tagName":"h2"},{"title":"Image-Historie‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#image-historie","content":" Der Befehl docker history &lt;image&gt; gibt Auskunft √ºber die Schichten eines Images und kann helfen zu verstehen, wie ein Image aufgebaut wurde.  ","version":"Next","tagName":"h2"},{"title":"Container-Events‚Äã","type":1,"pageTitle":"Debugging von Containern","url":"/workshop-container/docs/debugging#container-events","content":" Um eine Chronik von Events, die einen bestimmten Container betreffen, zu sehen, nutze docker events &lt;container&gt;. Dies kann bei der Diagnose von Start- oder Netzwerkproblemen hilfreich sein.  Mit diesen Werkzeugen und Techniken bist du gut ger√ºstet, um die h√§ufigsten Probleme bei der Arbeit mit Docker-Containern zu diagnostizieren und zu beheben. ","version":"Next","tagName":"h2"},{"title":"8.1 Mehrstufiger Build","type":0,"sectionRef":"#","url":"/workshop-container/docs/image_build/08_01_multistage_build","content":"","keywords":"","version":"Next"},{"title":"Einf√ºhrung in Multistage Builds‚Äã","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#einf√ºhrung-in-multistage-builds","content":" Das Ziel eines Multistage Builds ist es, die Gr√∂√üe des finalen Images zu minimieren und die Sicherheit zu erh√∂hen, indem nur die notwendigen Abh√§ngigkeiten und Artefakte im finalen Image enthalten sind. Dies ist besonders n√ºtzlich in Sprachen und Umgebungen, in denen der Build-Prozess Abh√§ngigkeiten und Tools ben√∂tigt, die zur Laufzeit nicht erforderlich sind.  ","version":"Next","tagName":"h2"},{"title":"Beispiel: Optimierung des Python-App-Images‚Äã","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#beispiel-optimierung-des-python-app-images","content":" Angenommen, wir haben eine Python-Webanwendung entwickelt, die wir in einem Docker-Container deployen m√∂chten. Der Build-Prozess f√ºr die Anwendung erfordert verschiedene Abh√§ngigkeiten, aber f√ºr die Ausf√ºhrung der Anwendung sind nicht alle Build-Abh√§ngigkeiten notwendig.  ","version":"Next","tagName":"h2"},{"title":"Dockerfile vor der Optimierung‚Äã","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#dockerfile-vor-der-optimierung","content":" Das urspr√ºngliche Dockerfile k√∂nnte folgenderma√üen aussehen:  FROM python:3.12-slim WORKDIR /app COPY ./python-app/ /app/ RUN pip install -r requirements.txt CMD [&quot;python&quot;, &quot;app.py&quot;]   ","version":"Next","tagName":"h3"},{"title":"Dockerfile nach der Optimierung mit Multistage Build‚Äã","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#dockerfile-nach-der-optimierung-mit-multistage-build","content":" Wir k√∂nnen das Dockerfile optimieren, indem wir einen Multistage Build verwenden:  Dockerfile # Build-Stage FROM python:3.12-slim AS builder WORKDIR /build COPY ./python-app/requirements.txt /build/ RUN pip install --target=/build/dependencies -r requirements.txt # Final-Stage FROM python:3.12-slim WORKDIR /app COPY --from=builder /build/dependencies /usr/local COPY ./python-app/ /app/ CMD [&quot;python&quot;, &quot;app.py&quot;]   ","version":"Next","tagName":"h3"},{"title":"Erkl√§rung‚Äã","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#erkl√§rung","content":" Build-Stage: Diese Stage verwendet das python:3.12-slim-Image, um eine Umgebung f√ºr den Build-Prozess bereitzustellen. Hier werden die Abh√§ngigkeiten der Anwendung installiert. Durch die Verwendung von --target=/build/dependencies werden die Abh√§ngigkeiten in einem separaten Verzeichnis gespeichert, das sp√§ter im finalen Image verwendet werden kann. Final-Stage: Diese Stage startet ebenfalls mit dem python:3.12-slim-Image, um das finale Image so klein wie m√∂glich zu halten. Hier werden nur die notwendigen Abh√§ngigkeiten aus der Build-Stage kopiert. Anschlie√üend wird der Anwendungscode in das Image kopiert.  ","version":"Next","tagName":"h3"},{"title":"Vorteile‚Äã","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#vorteile","content":" Gr√∂√üenreduktion: Das finale Image enth√§lt nur die f√ºr die Ausf√ºhrung der Anwendung notwendigen Abh√§ngigkeiten und Artefakte, was zu einem kleineren Image f√ºhrt.Sicherheit: Weniger Code und weniger Abh√§ngigkeiten im finalen Image bedeuten eine geringere Angriffsfl√§che f√ºr Sicherheitsl√ºcken.Effizienz: Multistage Builds erm√∂glichen die Wiederverwendung von Zwischenimages, was den Build-Prozess beschleunigen kann, besonders wenn mehrere Builds durchgef√ºhrt werden.  ","version":"Next","tagName":"h3"},{"title":"Bau des Images‚Äã","type":1,"pageTitle":"8.1 Mehrstufiger Build","url":"/workshop-container/docs/image_build/08_01_multistage_build#bau-des-images","content":" Um das Image zu bauen, f√ºhre einfach den folgenden Befehl aus:  docker build -t optimierte-python-app .   Durch die Anwendung von Multistage Builds kannst du effizientere, sicherere und kleinere Docker-Images erstellen, die speziell auf die Anforderungen Ihrer Anwendung zugeschnitten sind. ","version":"Next","tagName":"h3"},{"title":"Sicherheitsscans","type":0,"sectionRef":"#","url":"/workshop-container/docs/image_build/08_02_security_scanning","content":"","keywords":"","version":"Next"},{"title":"Trivy‚Äã","type":1,"pageTitle":"Sicherheitsscans","url":"/workshop-container/docs/image_build/08_02_security_scanning#trivy","content":" Installiere Trivy auf deinem Computer, indem du die Anweisungen auf der offiziellen Trivy-Websitefolgst.  Sobald Trivy installiert ist, kannst du ein Bild scannen, indem du den folgenden Befehl eingibst:  trivy image &lt;image-name&gt;   Das Ergebnis sollte √§hnlich wie folgt aussehen:  2024-02-09T15:27:06.080+0100 INFO Need to update DB 2024-02-09T15:27:06.080+0100 INFO DB Repository: ghcr.io/aquasecurity/trivy-db 2024-02-09T15:27:06.080+0100 INFO Downloading DB... 42.79 MiB / 42.79 MiB [----------------------------------------------------------------------------------------] 100.00% 18.23 MiB p/s 2.5s 2024-02-09T15:27:09.741+0100 INFO Vulnerability scanning is enabled 2024-02-09T15:27:09.741+0100 INFO Secret scanning is enabled 2024-02-09T15:27:09.741+0100 INFO If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2024-02-09T15:27:09.741+0100 INFO Please see also https://aquasecurity.github.io/trivy/v0.49/docs/scanner/secret/#recommendation for faster secret detection 2024-02-09T15:27:11.293+0100 INFO Detected OS: alpine 2024-02-09T15:27:11.293+0100 INFO Detecting Alpine vulnerabilities... 2024-02-09T15:27:11.293+0100 INFO Number of language-specific files: 0 2024-02-09T15:27:11.293+0100 WARN This OS version is no longer supported by the distribution: alpine 3.10.9 2024-02-09T15:27:11.293+0100 WARN The vulnerability detection may be insufficient because security updates are not provided alpine:3.10 (alpine 3.10.9) Total: 1 (UNKNOWN: 0, LOW: 0, MEDIUM: 0, HIGH: 0, CRITICAL: 1) ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Library ‚îÇ Vulnerability ‚îÇ Severity ‚îÇ Status ‚îÇ Installed Version ‚îÇ Fixed Version ‚îÇ Title ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ apk-tools ‚îÇ CVE-2021-36159 ‚îÇ CRITICAL ‚îÇ fixed ‚îÇ 2.10.6-r0 ‚îÇ 2.10.7-r0 ‚îÇ libfetch: an out of boundary read while libfetch uses strtol ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ to parse... ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ https://avd.aquasec.com/nvd/cve-2021-36159 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ","version":"Next","tagName":"h2"},{"title":"Einf√ºhrung","type":0,"sectionRef":"#","url":"/workshop-container/docs/intro","content":"Einf√ºhrung In diesem Training wirst du die Grundlagen hinter der Containertechnologie Docker lernen. Was sind Container?Docker auf deinem Computer installierenDocker-Container ausf√ºhrenLokale Volumes in Container einbindenDocker-Container erstellenWie Netzwerken funktioniert Zus√§tzliche Unterlagen Offizielle Docker Dokumentation","keywords":"","version":"Next"},{"title":"Docker Images","type":0,"sectionRef":"#","url":"/workshop-container/docs/images","content":"Docker Images Du kannst nach auf Docker Hub verf√ºgbaren Images suchen, indem du auf den Link &quot;Explore&quot; klickst oder &quot;mariadb&quot; in das Suchfeld eingibst:https://hub.docker.com/search/?q=mariadb&amp;type=image Du erh√§ltst eine Liste mit Ergebnissen und der erste Treffer wird wahrscheinlich das offizielle Image sein: https://hub.docker.com/_/mariadb Diese Seite enth√§lt Anweisungen, wie das Image abgerufen werden kann. Lass uns das machen: docker pull mariadb Hinweis Achte auf Sicherheit! √úberpr√ºfe die Images, bevor du sie ausf√ºhrst. Ist es ein offizielles Image?Was ist in dem Image installiert? Lies das Dockerfile, das zum Erstellen des Images verwendet wurde√úberpr√ºfe das Basis-Image Nachdem ein Image heruntergeladen wurde, kannst du dann einen Container mit dem heruntergeladenen Image mit dem Unterbefehl run ausf√ºhren. Wenn ein Image nicht heruntergeladen wurde, wenn Docker mit dem Unterbefehl run ausgef√ºhrt wird, wird der Docker-Client zuerst das Image herunterladen und dann einen Container damit ausf√ºhren: docker run mariadb:latest Hinweis Hier verwenden wir das latest Tag, um die neueste Version des Images zu verwenden. Es ist jedoch eine gute Praxis, ein spezifisches Tag zu verwenden, um sicherzustellen, dass du immer die gleiche Version des Images verwendest. Um die Images zu sehen, die auf deinen Computer heruntergeladen wurden, gib ein: docker images Die Ausgabe sollte √§hnlich wie folgt aussehen: REPOSITORY TAG IMAGE ID CREATED SIZE mariadb latest 58730544b81b 2 weeks ago 397MB hello-world latest 1815c82652c0 2 months ago 1.84kB hello-world linux 1815c82652c0 2 months ago 1.84kB Der Hello-World-Container, den du im vorherigen Lab ausgef√ºhrt hast, ist ein Beispiel f√ºr einen Container, der l√§uft und beendet wird, nachdem er eine Testnachricht ausgegeben hat. Container k√∂nnen jedoch viel n√ºtzlicher sein und sie k√∂nnen interaktiv sein. Schlie√ülich sind sie √§hnlich wie virtuelle Maschinen, nur ressourcenfreundlicher. Als Beispiel f√ºhren wir einen Container mit dem neuesten Image von MariaDB aus. Die Kombination der Schalter -i und -t gibt dir interaktiven Shell-Zugriff auf den Container: docker run -it mariadb:latest Hinweis f√ºr Windows Wenn du git-bash, cmd oder powershell auf einem Windows-System verwendest, achte auf den Fehler: the input device is not a TTY. If you are using mintty, try prefixing the command with 'winpty' Setze winpty am Anfang jedes Befehls, der die -it Parameter verwendet. Zum Beispiel: winpty docker run -it mariadb:latest Ein Fehler ist aufgetaucht! 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:11.2.2+maria~ubu2204 started. 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql' 2024-02-09 11:44:31+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:11.2.2+maria~ubu2204 started. 2024-02-09 11:44:31+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ROOT_PASSWORD_HASH, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD ü§î Warum ist dieser Fehler aufgetreten? Ist es ein Bug im Image? Alles ist in Ordnung, um dieses Image auszuf√ºhren, ist eine gewisse Konfiguration erforderlich. Lies den folgenden Auszug sorgf√§ltig durch. error: database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD ü§î Was ist ein Image? Denke an ein Image wie an einen Bauplan, der verwendet wird, um Container zu erstellen. Ein Image ist eine Sammlung von Dateien + einigen Metadaten (oder in technischen Begriffen: diese Dateien bilden das Root-Dateisystem eines Containers)Images bestehen aus Schichten, die konzeptionell √ºbereinander gestapelt sindJede Schicht kann Dateien hinzuf√ºgen, ver√§ndern oder entfernenImages k√∂nnen Schichten teilen, um die Nutzung von Festplattenspeicher, √úbertragungszeiten und Speichernutzung zu optimierenDu baust diese Images mit Hilfe von Dockerfiles (in sp√§teren Labs)Images sind unver√§nderlich, du kannst sie nach der Erstellung nicht √§ndern ü§î Was ist der Unterschied zwischen einem Container und einem Image? Wenn du ein Image ausf√ºhrst, wird es zu einem Container. Ein Image ist ein schreibgesch√ºtztes DateisystemEin Container ist ein eingekapselter Satz von Prozessen, der in einer schreibbaren Kopie dieses Dateisystems l√§uftdocker run startet einen Container aus einem gegebenen Image","keywords":"","version":"Next"},{"title":"8. Wie funktioniert das Image-Building?","type":0,"sectionRef":"#","url":"/workshop-container/docs/image_build/","content":"","keywords":"","version":"Next"},{"title":"Dockerfile‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#dockerfile","content":" Docker kann Container-Images erstellen, indem es Anweisungen aus einem sogenannten Dockerfile oder allgemeiner einem Containerfile liest. Die grundlegende Dokumentation dazu, wie Dockerfiles funktionieren, findest du unter https://docs.docker.com/engine/reference/builder/.  ","version":"Next","tagName":"h2"},{"title":"Schreibe dein erstes Dockerfile‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#schreibe-dein-erstes-dockerfile","content":" Bevor wir unser Python-Image erweitern, werden wir uns generell anschauen, wie man ein Container-Image erstellt. Daf√ºr erstelle ein neues Verzeichnis mit einem leeren Dockerfile darin.  mkdir myfirstimage cd myfirstimage   F√ºge den folgenden Inhalt zum Dockerfile mit deinem bevorzugten Editor hinzu:  Dockerfile FROM ubuntu RUN apt-get update &amp;&amp; \\ apt-get install -y figlet &amp;&amp; \\ apt-get clean   FROM gibt das Basis-Image f√ºr unseren Build anJede RUN-Zeile wird von Docker w√§hrend des Builds ausgef√ºhrtUnsere RUN-Befehle m√ºssen nicht-interaktiv sein (keine Eingabe kann w√§hrend des Builds an Docker bereitgestellt werden)√úberpr√ºfe https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/ f√ºr weitere Best Practices, wie man Dockerfiles schreibt.  ","version":"Next","tagName":"h2"},{"title":"Baue das Image‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#baue-das-image","content":" F√ºhre einfach aus:  docker build -t myfirstimage .   -t gibt das Tag an, das auf das Image angewendet werden soll. gibt den Ort des Build-Kontexts an (√ºber den wir sp√§ter noch mehr sprechen werden, aber im Grunde ist es das Verzeichnis, in dem unser Dockerfile liegt)  Hinweis Verwende den zus√§tzlichen Parameter --build-arg, wenn du hinter einem Firmenproxy bist: docker build -t myfirstimage --build-arg http_proxy=http://&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt; .   Bitte beachte, dass das Tag in den meisten Docker-Befehlen und Anweisungen weggelassen werden kann. In diesem Fall ist das Standard-Tag latest. Abgesehen davon, dass es das Standard-Tag ist, hat latest nichts Besonderes. Trotz seines Namens identifiziert es nicht notwendigerweise die neueste Version eines Images. Je nach Build-System kann es auf das zuletzt gepushte Image, auf das zuletzt aus einem Zweig gebaute Image oder auf ein altes Image zeigen. Es kann sogar √ºberhaupt nicht existieren. Aus diesem Grund solltest du niemals das Tag latest in Produktion verwenden, verwende immer eine spezifische Image-Version. Siehe auch: https://medium.com/@mccode/the-misunderstood-docker-tag-latest-af3babfd6375  ","version":"Next","tagName":"h2"},{"title":"Was passiert beim Build des Images‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#was-passiert-beim-build-des-images","content":" Die Ausgabe des Docker-Builds sieht folgenderma√üen aus:  Sending build context to Docker daemon 2.048kB Step 1/2 : FROM ubuntu ---&gt; ea4c82dcd15a Step 2/2 : RUN apt-get update &amp;&amp; apt-get install -y figlet &amp;&amp; apt-get clean ---&gt; b3c08112fd1c Successfully built b3c08112fd1c Successfully tagged myfirstimage:latest   ","version":"Next","tagName":"h3"},{"title":"Das Senden des Build-Kontexts an Docker‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#das-senden-des-build-kontexts-an-docker","content":" Sending build context to Docker daemon 84.48 kB ...   Der Build-Kontext ist das .-Verzeichnis, das an docker build √ºbergeben wurdeEs wird (als Archiv) vom Docker-Client an den Docker-Daemon gesendetDies erm√∂glicht es dir, eine Remote-Maschine zum Bauen unter Verwendung lokaler Dateien zu verwendenSei vorsichtig (oder geduldig), wenn dieses Verzeichnis gro√ü ist und deine Verbindung langsam ist  ","version":"Next","tagName":"h3"},{"title":"Untersuchung der Ausf√ºhrungsschritte‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#untersuchung-der-ausf√ºhrungsschritte","content":" ... Step 1/2 : FROM ubuntu ---&gt; ea4c82dcd15a Step 2/2 : RUN apt-get update &amp;&amp; apt-get install -y figlet &amp;&amp; apt-get clean ---&gt; b3c08112fd1c Successfully built b3c08112fd1c Successfully tagged myfirstimage:latest   Ein Container (ea4c82dcd15a) wird aus dem Basis-Image erstellt Das Basis-Image wird heruntergeladen, falls es vorher nicht heruntergeladen wurde Der RUN-Befehl wird in diesem Container ausgef√ºhrtDer Container wird zu einem Image (b3c08112fd1c) committedDer Build-Container (ea4c82dcd15a) wird entferntDas Ergebnis dieses Schritts wird die Basis f√ºr den n√§chsten sein...  ","version":"Next","tagName":"h3"},{"title":"Das Caching-System‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#das-caching-system","content":" Wenn du denselben Build erneut ausf√ºhrst, wird er sofort abgeschlossen. Warum?  Nach jedem Build-Schritt macht Docker ein SnapshotBevor ein Schritt ausgef√ºhrt wird, √ºberpr√ºft Docker, ob es dieselbe Sequenz bereits gebaut hatDocker verwendet die exakten Strings, die in deinem Dockerfile definiert sind: RUN apt-get install figlet cowsay unterscheidet sich vonRUN apt-get install cowsay figletRUN apt-get update wird nicht erneut ausgef√ºhrt, wenn die Spiegel aktualisiert werden Alle Schritte nach einem ge√§nderten Schritt werden erneut ausgef√ºhrt, da das Dateisystem, auf dem sie basieren, ge√§ndert worden sein k√∂nnte  Du kannst einen Neubau mit docker build --no-cache ... erzwingen.  Wenn du nur einen teilweisen Neubau ausl√∂sen m√∂chtest, z.B. apt-get update ausf√ºhren, um die neuesten Updates zu installieren, kannst du folgendes Muster verwenden:  ENV REFRESHED_AT 2020-03-13 RUN apt-get update   Wenn du den Wert von REFRESHED_AT aktualisierst, wird der Docker-Build-Cache dieses und aller folgenden Schritte invalidiert, wodurch die neuesten Updates installiert werden.  ","version":"Next","tagName":"h3"},{"title":"F√ºhre es aus‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#f√ºhre-es-aus","content":" F√ºhre jetzt dein Image aus  docker run -ti myfirstimage   Du findest dich in einer Bash-Shell im Container wieder, f√ºhre aus  figlet hello   und du wirst folgende Ausgabe sehen:  root@00f0766080ed:/# figlet hello _ _ _ | |__ ___| | | ___ | '_ \\ / _ \\ | |/ _ \\ | | | | __/ | | (_) | |_| |_|\\___|_|_|\\___/ root@00f0766080ed:/#   Verlasse den Container durch Ausf√ºhren von:  exit   ","version":"Next","tagName":"h3"},{"title":"Die CMD-Anweisung im Dockerfile‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#die-cmd-anweisung-im-dockerfile","content":" Mit der CMD-Anweisung im Dockerfile k√∂nnen wir den Befehl definieren, der ausgef√ºhrt wird, wenn ein Container gestartet wird.  ü§î Kannst du herausfinden, welche CMD-Anweisung das Ubuntu-Image hat? Du hast dich in einer Shell befunden, daher muss die Anweisung entweder /usr/bin/bash oder /usr/bin/sh sein.  Modifiziere das zuvor erstellte Dockerfile wie folgt:  FROM ubuntu RUN apt-get update &amp;&amp; \\ apt-get install -y figlet &amp;&amp; \\ apt-get clean CMD [&quot;figlet&quot;, &quot;hello&quot;]   Baue das Image mit:  docker build -t myfirstimagecmd .   Hinweis Verwende erneut den zus√§tzlichen Parameter --build-arg, wenn du hinter einem Firmenproxy bist: docker build -t myfirstimagecmd --build-arg http_proxy=http://&lt;username&gt;:&lt;password&gt;@&lt;proxy&gt;:&lt;port&gt; .   Und f√ºhre es aus:  docker run -ti myfirstimagecmd   Es f√ºhrt direkt den definierten Befehl aus und gibt aus   _ _ _ | |__ ___| | | ___ | '_ \\ / _ \\ | |/ _ \\ | | | | __/ | | (_) | |_| |_|\\___|_|_|\\___/   Weitere Informationen findest du unter https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact.  ","version":"Next","tagName":"h2"},{"title":"Frontend-App-Image bauen‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#frontend-app-image-bauen","content":" Nachdem wir die Grundlagen des Image-Buildings verstanden haben, m√∂chten wir nun den Quellcode unserer Frontend-App in ein bereits erstelltes Container-Image einbinden. Dazu werden wir ein Dockerfile erstellen.  Das Basis-Image ist unser php:8-apache-Image, das wir zuvor verwendet haben. Der ADD-Befehl erm√∂glicht es uns, Dateien aus unserem aktuellen Verzeichnis zum Docker-Image hinzuzuf√ºgen. Wir verwenden diesen Befehl, um den Anwendungsquellcode in das Image einzuf√ºgen.  Hinweis Verwende .dockerignore, um Dateien vom Hinzuf√ºgen zum Container durch den Docker-Kontext auszuschlie√üen. Es funktioniert genauso wie .gitignore: https://docs.docker.com/engine/reference/builder/#dockerignore-file  Im Verzeichnis, das das Unterverzeichnis python-app enth√§lt, erstelle ein Dockerfile mit dem folgenden Inhalt:  FROM python:3.12-slim # Kopiert den Python-Quellcode an den korrekten Ort ADD ./python-app/ /app/ # Setzt das Arbeitsverzeichnis WORKDIR /app # Installiert Abh√§ngigkeiten RUN pip install -r requirements.txt # Startet die Anwendung CMD [&quot;python&quot;, &quot;app.py&quot;]   ","version":"Next","tagName":"h2"},{"title":"Baue das python-app-Image‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#baue-das-python-app-image","content":" Hinweis Stoppe und l√∂sche den laufenden python-app-Container zuerst. Lasse den Datenbank-Container laufen.  Baue nun das Image:  docker build -t python-app .   ","version":"Next","tagName":"h3"},{"title":"F√ºhre den python-app-Container aus‚Äã","type":1,"pageTitle":"8. Wie funktioniert das Image-Building?","url":"/workshop-container/docs/image_build/#f√ºhre-den-python-app-container-aus","content":" Nach einem erfolgreichen Build f√ºhre ihn aus:  docker run -d --network container-basics-training --name python-app -p 5000:5000 python-app   √ñffne nun einen Browser und navigiere zu http://localhost:5000 (oder in der Webshell verwende curl http://localhost:5000). Du solltest eine Antwort erhalten, die besagt, dass die Verbindung erfolgreich hergestellt wurde. ","version":"Next","tagName":"h3"},{"title":"6. Volumes","type":0,"sectionRef":"#","url":"/workshop-container/docs/volumes","content":"","keywords":"","version":"Next"},{"title":"Ein Volume in einem Container einbinden‚Äã","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#ein-volume-in-einem-container-einbinden","content":" Der MariaDB-Container ist ein gutes Beispiel daf√ºr, warum es gut ist, ein externes Volume zu haben. Es gibt mehrere M√∂glichkeiten, wie man mit Volumes in Docker arbeiten kann, in diesem Fall werden wir ein von Docker verwaltetes Volume erstellen, um die persistenten Daten unserer MariaDB zu speichern. Das Volume wird von Docker selbst verwaltet.  Erstelle das von Docker verwaltete Volume mit:  docker volume create volume-mariadb   Nun benutze das erstellte Volume und h√§nge es an die MariaDB-Datenbank an.  Mit dem Parameter -v das Volume an einen Pfad im Container anh√§ngen:  docker run --name mariadb-container-with-external-volume -v volume-mariadb:/var/lib/mysql -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb   Siehe Dokumentation zu Docker-Volumes f√ºr mehr Informationen.  Okay, nun erstelle einen neuen Benutzer im MariaDB-Container:  docker exec -it mariadb-container-with-external-volume mariadb -uroot -pmy-secret-pw   Im mariadb-Client f√ºhre einige SQL-Befehle aus:  use mysql CREATE USER 'peter'@'%' IDENTIFIED BY 'venkman'; GRANT SELECT ON * . * TO 'peter'@'%';   Sobald alle Schritte abgeschlossen sind, beende die MySQL-Sitzung und verlasse den Container:  exit;   Um zu testen, ob Peter korrekt erstellt wurde, einfach mit seinen Anmeldedaten einloggen.  Nun stoppe und entferne den mariadb-container-with-external-volume Container.  docker stop mariadb-container-with-external-volume docker rm mariadb-container-with-external-volume   Als N√§chstes √ºberpr√ºfe, ob die Daten noch verf√ºgbar sind. Erstelle einen neuen MariaDB-Container mit dem vorherigen Volume:  docker run --name mariadb-container-with-existing-external-volume \\ -v volume-mariadb:/var/lib/mysql \\ -e MARIADB_ROOT_PASSWORD=my-secret-pw \\ -d mariadb   Der Moment der Wahrheit... Verbinde dich mit dem Datenbankserver mit Peters Anmeldedaten:  docker exec -it mariadb-container-with-existing-external-volume mariadb -upeter -pvenkman   Du solltest nun als peter mit deiner Datenbankinstanz verbunden sein. Du kannst dies testen, indem du die Benutzer mit dem SQL-Client auflistest:  SELECT User FROM mysql.user;   +-----------------+ | USER() | +-----------------+ | peter@localhost | +-----------------+ 1 Zeile in Satz (0.00 Sek.)   Jetzt verlasse den MySQL-Client  exit;   ","version":"Next","tagName":"h2"},{"title":"Zus√§tzliche Infos zur Arbeit mit Docker-Volumes‚Äã","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#zus√§tzliche-infos-zur-arbeit-mit-docker-volumes","content":" Docker-Volumes k√∂nnen verwendet werden f√ºr:  Entkoppeln der gespeicherten Daten vom Container, der die Daten erstellt hatUmgehen des Copy-on-Write-Systems, um native Festplatten-I/O-Leistung zu erzielenUmgehen von Copy-on-Write, um einige Dateien aus dem Docker-Commit auszuschliessenTeilen eines Verzeichnisses zwischen mehreren ContainernTeilen eines Verzeichnisses zwischen dem Host und einem ContainerTeilen einer einzelnen Datei zwischen dem Host und einem Container Eine Alternative zur Arbeit mit Volumes w√§re das Einbinden lokaler Verzeichnisse (Host-Ordner) √ºber einen Pfad in deinen Container. Dies werden wir in Kapitel 08 verwenden.  ","version":"Next","tagName":"h2"},{"title":"Docker-Speichertreiber‚Äã","type":1,"pageTitle":"6. Volumes","url":"/workshop-container/docs/volumes#docker-speichertreiber","content":" Wenn du viele Docker-Container auf einer Maschine betreibst, ben√∂tigst du normalerweise viel Speicher. Docker-Volumes und Container-Speicher werden auf einem Dateisystem bereitgestellt. Der folgende Link bietet zus√§tzliche Informationen dar√ºber, wie du das richtige Speichersetup ausw√§hlst:  https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/managing_containers/managing_storage_with_docker_formatted_containers  Derzeit ist overlay2 der empfohlene Speichertreiber. ","version":"Next","tagName":"h3"},{"title":"Umgebungsvariablen (Environment Variables)","type":0,"sectionRef":"#","url":"/workshop-container/docs/umgebungs_variablen","content":"","keywords":"","version":"Next"},{"title":"Detached Containers‚Äã","type":1,"pageTitle":"Umgebungsvariablen (Environment Variables)","url":"/workshop-container/docs/umgebungs_variablen#detached-containers","content":" Es gibt eine M√∂glichkeit, Container im Hintergrund laufen zu lassen, ohne dass sie die Shell blockieren. Daf√ºr musst du den Parameter -d verwenden, z.B.:  docker run -d -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb   Wenn du den Befehl ausf√ºhrst, wirst du eine Ausgabe wie diese sehen:  1a84e2e51ff2   Das ist die ID des Containers, die du verwenden kannst, um auf den Container zuzugreifen oder ihn zu stoppen. Wenn du nun alle laufenden Container sehen m√∂chtest, verwende den folgenden Befehl:  docker ps   Die Ausgabe sollte √§hnlich wie folgt aussehen:  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1a84e2e51ff2 mariadb &quot;docker-entrypoint.s‚Ä¶&quot; 3 minutes ago Up 3 minutes 3306/tcp amazing_mendeleev  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}